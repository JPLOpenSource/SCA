/**
 * Abstract class that serves as a basis for any code generation class.
 * This class is intended to contain the overall code generation strategy
 * that subclasses can specialize for their language of choice.  No
 * language-specific construct should exists here, except for convenience
 * methods to help create or rename variables to follow certain common C-type
 * constructs.
 */
package gov.nasa.jpl.statechart.autocode;

import gov.nasa.jpl.statechart.Autocoder;
import gov.nasa.jpl.statechart.Util;
import gov.nasa.jpl.statechart.core.CompositeState;
import gov.nasa.jpl.statechart.core.CompositeStateRegion;
import gov.nasa.jpl.statechart.core.SimpleState;
import gov.nasa.jpl.statechart.core.State;
import gov.nasa.jpl.statechart.core.StateMachine;
import gov.nasa.jpl.statechart.core.SubmachineState;

import java.io.PrintStream;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;


public abstract class StateChartCodeWriter
{
   // Whitespace tokens for proper indentation in the output
   protected static final String INDENT_STEP = "   ";
   protected static final String INDENT_CASE = "    ";
   protected static final String NO_INDENT   = "";

   // Configuration flags
   //
   // executionTraceOn : injects code to track the full path of the
   //                    currently executing state.
   //
   // qualifySignalNames: Creates a unique path to each element 
   //                     within the state machine.  This is useful
   //                     for state charts that contain submachines
   //                     or orthogonal regions where it is logical
   //                     to get multiple states the same name.
   // 
   //                     For simple state machines, this option 
   //                     can be disabled to improve the readability
   //                     of the generated code
   //
   protected final boolean executionTraceOn = Autocoder.isExecutionTraceOn();
      
   protected final boolean qualifySignalNames = Autocoder.qualifySignals();

   // State machine that is being processed
   protected final StateMachine stateMachine;

   // Name of the output file
   protected String currentFilename = "";

   // Class variable to track the indentation level.  There are convenience
   // function for manipulating this
   protected String indent = "";

   // Output stream.  Provided for convenience rather than forcing all the
   // method to pass around a PrintStream variable
   protected PrintStream out = null;
      
   // A cache of all the states excluding submachines
   private Map<String, State> stateMap = null;
   
   // Mark if a state machine is contained within an orthogonal region.  This
   // is a hack that could be removed if we expanded the submachines into
   // the DOM tree when we parse the UML diagram.
   protected boolean inOrthogonalRegion = false;


   public StateChartCodeWriter( StateMachine stateMachine )
   {
      this.stateMachine = stateMachine;
   }

   protected void setPrintStream( PrintStream out )
   {
      this.out = out;
   }

   public void setWithinRegion( boolean inRegion )
   {
      this.inOrthogonalRegion = inRegion;
   }

   public boolean isWithinRegion()
   {
      return inOrthogonalRegion;
   }


   protected PrintStream getPrintStream()
   {
      return out;
   }

   protected void incIndent()
   {
      incIndent( INDENT_STEP.length() );
   }

   protected void incIndent( int n )
   {
      this.indent = indent + Util.strrep( ' ', n );
   }

   protected void decIndent()
   {
      decIndent( INDENT_STEP.length() );
   }

   protected void decIndent( int n )
   {
      n = Math.max( 0, indent.length() - n );
      this.indent = Util.strrep( ' ', n );
   }

   protected void setIndent( int n )
   {
      n = Math.max( 0, indent.length() );
      this.indent = Util.strrep( ' ', n );
   }

   protected void setIndent( String indent )
   {
      this.indent = indent;
   }

   protected String getIndent()
   {
      return indent;
   }

   /**
    * Writes the comment block at the top of the header file
    */
   protected void writeCommentBlock()
   {
      int year = new GregorianCalendar().get( GregorianCalendar.YEAR );

      out.println("/**");
      out.println(" * @file " + currentFilename);
      out.println(" *");
      out.println(" * This file was generated by the SIM MagicDraw statechart converter,");
      out.println(" * which converts MagicDraw statecharts expressed in XML to Miro Samek's");
      out.println(" * C Quantum Framework.");
      out.println(" *");
      out.println(" * &copy; " + year + " Jet Propulsion Lab / California Institute of Technology");
      out.println(" */");
      out.println();
   }

   /**
    * Write the implementation code
    */      
   public abstract void writeCode( String filename );

   /**
    * Returns the namespace prefix of the state chart
    */
   public abstract String getClassPrefix();

   /**
    * Various static functions that are useful
    * 
    * Filter a map of all states by a specific state type
    */
   public static <T> Map<String, T> filterByType( Map<String, ?> map, Class<T> clazz )
   {
      Map<String, T> map2 = new HashMap<String, T>();

      for ( Map.Entry<String, ?> entry : map.entrySet() )
      {
         if ( clazz.isAssignableFrom( entry.getValue().getClass() ))
         {
            map2.put( entry.getKey(), clazz.cast( entry.getValue() ));
         }
      }

      return map2;
   }

   public static <T> Map<String, T> filterByExactType( Map<String, ?> map, Class<T> clazz )
   {
      Map<String, T> map2 = new HashMap<String, T>();

      for ( Map.Entry<String, ?> entry : map.entrySet() )
      {
         if ( clazz.equals( entry.getValue().getClass() ))
         {
            map2.put( entry.getKey(), clazz.cast( entry.getValue() ));
         }
      }

      return map2;
   }
   
   public static Map<String, CompositeStateRegion> filterByCompositeStateRegion( Map<String, State> map )
   {
      return filterByType( map, CompositeStateRegion.class );
   }
   
   public static Map<String, CompositeState> filterByHistoryContainers( Map<String, State> map )
   {      
      Map<String, CompositeState> map2 = filterByType( map, CompositeState.class );

      Iterator<CompositeState> iter = map2.values().iterator();

      while ( iter.hasNext() )
      {
         if ( !iter.next().containsHistoryState() )
            iter.remove();
      }
      
      return map2;
   }
   
   /**
    * Filter the set of states by those containing timer timeouts.
    */
   public static Map<String, SimpleState> filterByTimers( Map<String, State> map )
   {      
      Map<String, SimpleState> map2 = filterByType( map, SimpleState.class );

      Iterator<SimpleState> iter = map2.values().iterator();

      while ( iter.hasNext() )
      {
         if ( !iter.next().hasTimeout() )
            iter.remove();
      }
      
      return map2;
   }

   /**
    * Find the enclosing state machine of a given state.  Harder than you
    * think...   This is a slow implementation, but gets the job done.
    */
   public StateMachine getEnclosingStateMachine( State state )
   {
      // Filter out all the submachine states since we may need to 
      // recurse within them.
      Map<String, SubmachineState> submachines = 
         filterByType( stateMachine.getAllStates( true ), 
                       SubmachineState.class );

      Map<String, State> states = stateMachine.getAllStates();
      if ( states.values().contains( state ))
         return stateMachine;

      for ( SubmachineState submachine : submachines.values() )
      {
         StateMachine machine = submachine.getStateMachine();
         if ( machine.getAllStates().values().contains( state ))
            return machine;
      }

      return null;
   }

   /**
    * Sort the set of states into buckets depending on the enclosing region
    * of each.  This should be straighforward if we actually had a proper
    * DOM tree of the UML diagram.  But we have to work around the fact
    * that submachines are treated as simple nodes (leaves of the tree)
    *
    * This means that if getEnclosingRegion() return null, we have to check
    * and see if any of the submachines have the state as a top-level item.
    * If so, the search continues.
    */
   public Map<CompositeStateRegion, Map<String, SimpleState>>
      sortStatesByEnclosingRegion( Map<String, SimpleState> map )
   {
      // Filter out all the submachine states since we may need to 
      // recurse within them.
      Map<String, SubmachineState> submachines = 
         filterByType( stateMachine.getAllStates( true ), 
                       SubmachineState.class );


      // Instantiate the return map.  Always keep a "null" bucket, even
      // if it is empty
      Map<CompositeStateRegion, Map<String, SimpleState>> map2 = 
         new HashMap<CompositeStateRegion, Map<String, SimpleState>>();

      map2.put( null, new HashMap<String, SimpleState>() );

      // For each state, find the enclosing composite region.  We do a
      // little extra work in order to transition over the submachine
      // boundaries
      for ( Map.Entry<String, SimpleState> entry : map.entrySet() )
      {
         // Initialize the enclosing region to null
         CompositeStateRegion enclosingRegion = null;

         // Get the state of interest
         SimpleState state = entry.getValue();
         boolean done = false;

         while ( !done )
         {
            // Search this state machine for an enclosing region
            enclosingRegion = StateMachine.getEnclosingRegion( state );

            // Found an enclosing region, so break out.
            if ( enclosingRegion != null ) 
               break;

            // Otherwise, get the top-level parent of the state
            State topLevelState = StateMachine.getEnclosingState( state );

            // Do any of the other submachines contain this state in
            // their top-level set of states?  If so, find the enclosing
            // region of the submachine state and continue.
            done = true;

            for ( SubmachineState submachine : submachines.values() )
            {
               StateMachine sm = submachine.getStateMachine();

               if ( sm.getAllStates( 1 ).values().contains( topLevelState ))
               {
                  state = submachine;
                  done  = false;
                  break;
               }
            }
         }

         // The enclosing region vsriable will be null if we were able to
         // get to the top-level state machine without going through a
         // region          
         if ( !map2.containsKey( enclosingRegion ))
         {
            map2.put( enclosingRegion, new HashMap<String, SimpleState>() );
         }

         map2.get( enclosingRegion ).put( entry.getKey(), entry.getValue() );
      }

      return map2;
   }
}
