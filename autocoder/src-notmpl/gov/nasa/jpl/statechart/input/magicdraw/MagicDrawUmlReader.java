/**
 * Created Jul 24, 2009.
 * <p>
 * Copyright 2009, by the California Institute of Technology. ALL RIGHTS
 * RESERVED. United States Government Sponsorship acknowledged. Any commercial
 * use must be negotiated with the Office of Technology Transfer at the
 * California Institute of Technology.
 * </p>
 * <p>
 * This software is subject to U.S. export control laws and regulations and has
 * been classified as 4D993. By accepting this software, the user agrees to
 * comply with all applicable U.S. export laws and regulations. User has the
 * responsibility to obtain export licenses, or other export authority as may be
 * required before exporting such information to foreign countries or providing
 * access to foreign persons.
 * </p>
 */
package gov.nasa.jpl.statechart.input.magicdraw;

import gov.nasa.jpl.statechart.Autocoder;
import gov.nasa.jpl.statechart.Util;
import gov.nasa.jpl.statechart.core.Action;
import gov.nasa.jpl.statechart.core.CallAction;
import gov.nasa.jpl.statechart.core.CompositeState;
import gov.nasa.jpl.statechart.core.CompositeStateRegion;
import gov.nasa.jpl.statechart.core.ConcurrentCompositeState;
import gov.nasa.jpl.statechart.core.ConnectionPointReference;
import gov.nasa.jpl.statechart.core.CoordinatePoint;
import gov.nasa.jpl.statechart.core.DiagramSelfTransitionElement;
import gov.nasa.jpl.statechart.core.DiagramSeparatorElement;
import gov.nasa.jpl.statechart.core.DiagramStateElement;
import gov.nasa.jpl.statechart.core.DiagramTextElement;
import gov.nasa.jpl.statechart.core.DiagramTransitionElement;
import gov.nasa.jpl.statechart.core.EventAction;
import gov.nasa.jpl.statechart.core.FinalState;
import gov.nasa.jpl.statechart.core.InitialState;
import gov.nasa.jpl.statechart.core.JunctionState;
import gov.nasa.jpl.statechart.core.Path;
import gov.nasa.jpl.statechart.core.SimpleState;
import gov.nasa.jpl.statechart.core.State;
import gov.nasa.jpl.statechart.core.StateMachine;
import gov.nasa.jpl.statechart.core.SubmachineState;
import gov.nasa.jpl.statechart.core.Transition;
import gov.nasa.jpl.statechart.core.TransitionGuard;
import gov.nasa.jpl.statechart.core.TransitionTimeout;
import gov.nasa.jpl.statechart.input.ReaderNamespaceContext;
import gov.nasa.jpl.statechart.input.StateMachineXmiReader;
import gov.nasa.jpl.statechart.input.identifiers.UMLIdentifiers;
import gov.nasa.jpl.statechart.input.identifiers.UMLLabel;
import gov.nasa.jpl.statechart.input.identifiers.XMIIdentifiers;
import gov.nasa.jpl.statechart.input.identifiers.XMILabel;
import gov.nasa.jpl.statechart.uml.Model;
import gov.nasa.jpl.statechart.uml.UMLModel;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.XMLConstants;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;



/**
 * This class provides the common data and methods for all MagicDraw
 * UML reader versions to parse descriptions of UML state machines from XMI
 * files generated by the MagicDraw UML tool. The parser creates a model of the
 * state chart by building StateMachine objects containing States, Transitions,
 * etc. The state chart model can then be used to generate an implementation in
 * a language such as C/C++, Python, etc.
 * <p>
 * N.B.:  As this was abstracted from readers of two MagicDraw versions, 12.5
 * and 16.0, some shifting of functionalities between the super- and subclasses
 * may be in order.
 * </p>
 *
 * <p>
 * Copyright &copy; 2009 Jet Propulsion Lab / California Institute of Technology
 * </p>
 *
 * @author refactoring and function adding by Shang-Wen Cheng <scheng@jpl.nasa.gov>
 *
 */
public class MagicDrawUmlReader extends StateMachineXmiReader {

    // Keep a set of Lists and HashMaps for rapid cross referencing
    protected final Map<String,Element> xmiId = Util.newMap();
    protected final Set<gov.nasa.jpl.statechart.uml.StateMachine> stateMachines = Util.newSet();
    protected final Set<gov.nasa.jpl.statechart.uml.StateMachine> submachines = Util.newSet();
    private final int maxSearchDepth = 200;

    // Reader helper
    private MDUmlReaderHelper helper = MDUmlReaderHelper.NULL_READER;

    // internal data
    private List<Node> diagramList = new ArrayList<Node>();
    private List<Node> signalEventList = new ArrayList<Node>();
    private List<Node> timeEventList = new ArrayList<Node>();


    /**
     * Default constructor, initializes basic data structures.
     */
    public MagicDrawUmlReader () {
        super();
    }

    
    /* (non-Javadoc)
     * @see gov.nasa.jpl.statechart.input.StateMachineXmiReader#determineReaderVersion(org.w3c.dom.Document)
     */
    @Override
    protected boolean determineReaderVersion (Document doc) {
        // Look for the xmi:Documentation tag to find exporter and exporterVerion tags
        Element top = doc.getDocumentElement();

        if (!top.getLocalName().equals(XMILabel.TAG_XMI.defaultLiteral())) {
            System.err.println("This is not an XMI document");
            return false;
        }
        // otherwise, set XMI namespace version
        XMIIdentifiers.setNamespace(Util.getNodeAttribute(top, XMLConstants.XMLNS_ATTRIBUTE + ":" + XMIIdentifiers.XMINS_PREFIX_DEFAULT));
        // get the corresponding identifier instance
        XMIIdentifiers xmiId = XMIIdentifiers.inst();

        NodeList docNodes = doc.getElementsByTagNameNS(xmiId.lit(XMILabel.XMI_NS), xmiId.lit(XMILabel.TAG_DOCUMENTATION));  
        if (docNodes.getLength() != 1) {
            System.err.println("No XMI Documentation tag found!");
            return false;
        }
        // found XMI's Documentation tag, there should be only 1!
        Element docNode = (Element) docNodes.item(0);
        boolean foundMatch = false;  // did we find a matching version?
        if (docNode.getAttribute(xmiId.lit(XMILabel.KEY_EXPORTER)).equals(MDUmlReaderHelper.EXPORTER)) {
            String latestVer = MDUmlReaderHelper.inst().latestVersionSupported();
            for (String ver : MDUmlReaderHelper.getSupportedVersions()) {
                if (ver.equals(latestVer) /* we fall back to using our latest version */
                        || docNode.getAttribute(xmiId.lit(XMILabel.KEY_EXPORTER_VERSION)).equals(ver)) {
                    System.out.println("Input reader selected: " + MDUmlReaderHelper.EXPORTER + " ver. " + ver);
                    MDUmlReaderHelper.setVersion(ver);
                    helper = MDUmlReaderHelper.inst();
                    helper.setReader(this);
                    foundMatch = true;
                    break;
                }
            }
        }
        if (foundMatch) {  // set identifier instances for namespace version
            UMLIdentifiers.setNamespace(Util.getNodeAttribute(top, XMLConstants.XMLNS_ATTRIBUTE + ":" + UMLIdentifiers.UMLNS_PREFIX_DEFAULT));
            helper.setIdentifiers(XMIIdentifiers.inst(), UMLIdentifiers.inst());
            helper.xmi().setPrefix(doc.lookupPrefix(helper.xmi().lit(XMILabel.XMI_NS)));
            helper.uml().setPrefix(doc.lookupPrefix(helper.uml().lit(UMLLabel.UML_NS)));
            System.out.println("Namespace version selected for XMI is "
                    + helper.xmi().version() + " and UML is "
                    + helper.uml().version());
        } else {
            System.err.println("This reader supports only "
                    + MDUmlReaderHelper.supportedVersionsAsString());
            System.exit(-1);
        }

        return foundMatch;
    }

    /**
     * Return the DOM Nodes that correspond to the various state machines
     * diagrams.
     * 
     * These are all the <ownedBehavior> nodes with attribute
     * xmi:type="uml:StateMachine".
     * 
     * @see gov.nasa.jpl.statechart.input.StateMachineXmiReader#getStateMachines(org.w3c.dom.Document)
     */
    @Override
    protected Set<gov.nasa.jpl.statechart.uml.StateMachine> getStateMachines (Document document) {
        return Collections.unmodifiableSet(stateMachines);
    }

    /**
     * Find all the submachine references from a given root and follow the
     * xmi:idref in order to return the parent node of the appropriate state
     * machine
     * 
     * @see gov.nasa.jpl.statechart.input.StateMachineXmiReader#getSubmachines(gov.nasa.jpl.statechart.uml.StateMachine)
     */
    @Override
    protected Set<gov.nasa.jpl.statechart.uml.StateMachine> getSubmachines (gov.nasa.jpl.statechart.uml.StateMachine stateMachine) {
        Set<gov.nasa.jpl.statechart.uml.StateMachine> submachines = Util.newSet();

        // Iterate through all the regions looking for some submachines
        for (gov.nasa.jpl.statechart.uml.Region region : stateMachine.getRegion()) {
            // Get the state that owns this region
            gov.nasa.jpl.statechart.uml.State state = region.getState();

            if (state != null && state.isSubmachineState())
                submachines.add(state.getSubmachine());

//            for (StateChart.uml.Vertex vertex : region.getSubvertex()) {
//            }
        }

        /*
        NodeList nodes = stateMachine.getElementsByTagName( "submachineState" );
        Set<Element> submachines = new HashSet<Element>(); 
        
        for ( Element elem : filterElementsNS( nodes, XMI_NS, helper.KEY_IDREF, "*" ) ) 
        {
           Element node = xmiId.get( elem.getAttributeNS( XMI_NS, helper.KEY_IDREF ));
           submachines.add( new StateChart.uml.StateMachine( node ));
        }
        */
        return submachines;
    }

    /**
     * Given a root Element that represents a state machine, figure out the
     * path of a given state.
     *
     * The algorithm is simple:
     * <ul> 
     * <li> 1. Move up to the next parent while it is not equal to the root</li>
     * <li> 2. Keep a list of all the uml:State names</li>
     * <li> 3. If we reach a uml:StateMachine node, check to see what other
     *      state machines reference this state machine as a submachine</li>
     * <li> 4. Recursively search each state machine</li>
     * <li> 5. If the search reaches a state machine that is not referenced,
     *      then fail</li>
     * </ul>
     */
    public Path<Element> getPathToElement (Element root, Element state) {
        List<Element> path = new ArrayList<Element>();

        while (state != root) {
            state = (Element) state.getParentNode();
            if (state.getAttributeNS(helper.xmi().lit(XMILabel.XMI_NS), helper.xmi().lit(XMILabel.KEY_TYPE))
                    .equals(helper.uml().prefixed(UMLLabel.TYPE_STATE)))
                path.add(state);

            // Hit the state machine without matching the root, search for
            // references
            if (state.getAttributeNS(helper.xmi().lit(XMILabel.XMI_NS), helper.xmi().lit(XMILabel.KEY_TYPE))
                    .equals(helper.uml().prefixed(UMLLabel.TYPE_STATEMACHINE))) {
                // do nothing???
            }
        }

        return new Path<Element>(path);
    }

    /**
     * Create a UML Model from a MagicDraw XMI DOM
     * 
     * @see gov.nasa.jpl.statechart.input.StateMachineXmiReader#createUMLFromDOM(org.w3c.dom.Document)
     */
    @Override
    protected Model createUMLFromDOM (Document document) {
        /* Instantiate a UML Model from the XMI DOM. We look for a UML:Model
         * element contained in the top-level xmi:xmi node.
         * 
         * We also walk the tree and cache some common nodes.
         *
         * At this point, document should already be verified to be XMI.
         */
        gov.nasa.jpl.statechart.uml.Model model = null;
        if (document != null) {
            // Look for the MagicDraw-specific identifiers
            Element top = document.getDocumentElement();

            // Look for any <uml:Model> tags
            NodeList umlNodes = top.getElementsByTagNameNS(helper.uml().lit(UMLLabel.UML_NS), helper.uml().lit(UMLLabel.TAG_MODEL));
            if (umlNodes.getLength() == 0) {
                System.err.println("No UML Models found!");
                return null;
            }

            if (umlNodes.getLength() > 1) {
                System.out.println("Found more than one model.  Ignoring the rest.");
            }

            // Construct the UML class hierarchy
            model = new UMLModel(UMLModel.gatherStats(umlNodes.item(0)));
/*
            if (false) {
                NodeList nodes = document.getElementsByTagName("*");

                // Index the Nodes by xmi:id
                for (Element elem : Util.filterElementsNS(nodes, XMI_NS, helper.KEY_ID,
                        "*")) {
                    xmiId.put(elem.getAttributeNS(XMI_NS, helper.KEY_ID), elem);
                }

                // Keep a list of all the nodes with xmi:type of a StateMachine
                for (Element elem : Util.filterElementsNS(nodes, XMI_NS,
                        helper.xmi().lit(XMILabel.KEY_TYPE),
                        helper.uml().prefixed("StateMachine"))) {
                    stateMachines.add(new StateChart.uml.UMLStateMachine(elem));
                }

                // Other indexing....
            }
*/
        }
        return model;
    }

    /**
     * Parses through the node tree starting at the specified top level node,
     * and finds and adds all states, transitions, and diagram elements to the
     * specified state machine object.
     * 
     * @param machine
     *            StateMachine The state machine we're building.
     * @param smTopNode
     *            Node Start search at and below this node for states,
     *            transitions, etc.
     * @throws Exception
     * 
     * @see StateChart.StateMachineXmiReader#buildStateMachine(gov.nasa.jpl.statechart.core.StateMachine, org.w3c.dom.Node)
     */
    @Override
    protected void buildStateMachine (StateMachine machine, Node smTopNode) throws Exception {
        Node smDiagramTop = null;
        // Find the matching diagram model element for this state machine:
        findSmDiagram: for (Node nextdiagram : diagramList) {
            // Check if this diagram model element matches state machine's ID:
            if (machine.id().equals(Util.getNodeAttribute(nextdiagram,
                    helper.KEY_DIAGRAM_OWNER))) {
                if (Autocoder.ignoreDuplicateXmiIds()) {  // also check name!
                    if (machine.name().equalsIgnoreCase(Util.getNodeAttribute(nextdiagram, helper.xmi().lit(XMILabel.KEY_NAME)))) {
                        smDiagramTop = nextdiagram;
                        break findSmDiagram;
                    }
                } else {  // checking for ID match is sufficient
                    smDiagramTop = nextdiagram;
                    break findSmDiagram;
                }
            }
        }
        if (null == smDiagramTop)
            throw new Exception(
                    "State chart diagram information not found for state machine "
                            + machine.name() + " (ID= " + machine.id()
                            + ") - unable to parse!");
        machine.setCanvasSize(findWindowBounds(smDiagramTop));

        findNodes(machine.stateMdElementList(), helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.uml().lit(UMLLabel.TYPE_STATE),
                smDiagramTop, maxSearchDepth);
        findNodes(machine.stateMdElementList(), helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_PSEUDOSTATE,
                smDiagramTop, maxSearchDepth);
        findNodes(machine.stateMdElementList(), helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_DECISION,
                smDiagramTop, maxSearchDepth);
        findNodes(machine.transitionMdElementList(), helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_TRANSITION,
                smDiagramTop, maxSearchDepth);
        findNodes(machine.transitionMdElementList(), helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_TRANSITION_TO_SELF,
                smDiagramTop, maxSearchDepth);
        // Find all the region separators:
        findSeparators(machine, smDiagramTop);
        // Find all the text boxes for this state machine:
        findText(machine, smDiagramTop);

        // Find the top-level region node for this state machine:
        Node regionNode = findNode(helper.uml().lit(UMLLabel.TAG_REGION),
                XMIIdentifiers.type(),
                helper.uml().prefixed(UMLLabel.TYPE_REGION), smTopNode, 1);
        if (null == regionNode)
            throw new Exception(
                    "Invalid XMI file format - expecting top-level enclosing region within state machine.");
        // Find all the transitions for the topmost region:
        findTransitions(machine, regionNode);

        // Search all child nodes of this state machine for states:
        NodeList childNodes = regionNode.getChildNodes();
        if (null != childNodes) {
            for (int i = 0; i < childNodes.getLength(); i++) {
                findStates(machine, null, childNodes.item(i));
            }
        }
    }

    /**
     * Populates the subclass variables with top level information for all state
     * machines defined in the XMI file.
     * 
     * @param xmiTop
     *            Node The top of the XMI document to search.
     *
     * @see StateChart.StateMachineXmiReader#findOtherModelInfo(org.w3c.dom.Node)
     */
    @Override
    protected void findOtherModelInfo (Node xmiTop) throws Exception {
        // Find all UML diagram information:
        findDiagrams(xmiTop);
        // Find the starting UML model node:
        Node modelTop = modelTop(xmiTop);
        // Likewise, find other model-level items of interest:
        findNodes(signalEventList, helper.uml().lit(UMLLabel.TAG_MEMBER_ELEMENT),
                XMIIdentifiers.type(),
                helper.uml().prefixed(UMLLabel.TYPE_SIGNAL_EVENT),
                modelTop, maxSearchDepth);
        findNodes(timeEventList, helper.uml().lit(UMLLabel.TAG_MEMBER_ELEMENT),
                XMIIdentifiers.type(),
                helper.uml().prefixed(UMLLabel.TYPE_TIME_EVENT),
                modelTop, maxSearchDepth);
    }

    /**
     * Populates the diagramList class variable with found UML diagram
     * definition nodes.
     * 
     * @param xmiTop
     *            Node The top of the XMI document to search.
     */
    protected void findDiagrams(Node xmiTop) throws Exception {
        // Find the starting model diagrams node:
        Node mdOwnedDiagrams = findNode(helper.TAG_MD_OWNED_DIAGRAMS,
                findNode(helper.xmi().prefixed(XMILabel.KEY_EXTENSION), xmiTop, 1),
                1);
        if (null == mdOwnedDiagrams) {  // try again for magicdraw 12 (and >?)
            ArrayList<Node> list = new ArrayList<Node>();
            findNodes(list, helper.xmi().prefixed(XMILabel.KEY_EXTENSION),xmiTop, 1);

            // find the second extension
            if (list.size() < 2) {
                throw new Exception("File " + currentFilename
                        + " does not contain diagram information for the UML model - unable to parse!");
            }

            Node secondextension = list.get(1);
            mdOwnedDiagrams = findNode(helper.TAG_MD_OWNED_DIAGRAMS, secondextension, 1);
            if (null == mdOwnedDiagrams) {
                throw new Exception("File " + currentFilename
                        + " does not contain diagram information for the UML model - unable to parse!");
            }
        }

        // Find the model owned diagrams (which define diagram geometry
        // and other graphical information):
        findNodes(diagramList, helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_DIAGRAM,
                mdOwnedDiagrams, 1);
    }

    /**
     * Searches for region separator lines in the passed diagram, and adds them
     * to the passed state machine.
     * 
     * @param machine
     *            StateMachine The state machine to which to add the found
     *            separators.
     * @param smDiagramTop
     *            Node The top of the diagram node subtree to search.
     */
    private void findSeparators(StateMachine machine, Node smDiagramTop) {
        List<Node> splitNodeList = new ArrayList<Node>();
        findNodes(splitNodeList, helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_SPLIT,
                smDiagramTop, maxSearchDepth);
        for (Node splitNode : splitNodeList) {
            Node geometryNode = findNode(helper.TAG_MD_GEOMETRY, splitNode, 1);
            if (null != geometryNode) {
                // We have all the info needed to create a
                // DiagramSeparatorElement:
                int[] intArray = toIntArray(geometryNode.getFirstChild().getNodeValue());
                if (null != intArray && intArray.length == 4) {
                    // We have a good list of geometry points for this separator
                    // element.
                    machine.add(new DiagramSeparatorElement(intArray));
                }
            }
        }
    }

    /**
     * Finds all the text diagram elements below the specified node, and adds
     * them to the specified state machine.
     * 
     * @param machine
     *            The state machine to which to add text diagram elements.
     * @param smDiagramTop
     *            The top node of the state machine diagram.
     * @throws Exception
     */
    private void findText(StateMachine machine, Node smDiagramTop)
            throws Exception {
        List<Node> textNodeList = new ArrayList<Node>();
        findNodes(textNodeList, helper.TAG_MD_ELEMENT,
                helper.KEY_ELEMENT_CLASS, helper.MD_TEXTBOX,
                smDiagramTop, maxSearchDepth);
        for (Node textBoxNode : textNodeList) {
            Node textNode = findNode(helper.TAG_MD_TEXT, textBoxNode, 1);
            Node geometryNode = findNode(helper.TAG_MD_GEOMETRY, textBoxNode, 1);
            if (null != textNode && null != geometryNode) {
                // We have all the info needed to create a
                // DiagramTextElement:
                int[] intArray = toIntArray(geometryNode.getFirstChild().getNodeValue());
                if (null != intArray && intArray.length == 4) {
                    // We have a good list of geometry points for this state
                    // view element.
                    CoordinatePoint p0 = new CoordinatePoint(intArray[0]
                            + (intArray[2] / 2), intArray[1]);
                    DiagramTextElement diagramTextElement = new DiagramTextElement(
                            textNode.getFirstChild().getNodeValue(), p0);
                    machine.add(diagramTextElement);
                }
            }
        }
    }

    /**
     * Finds all transition nodes, below the specified starting node, and adds
     * them to the specified state machine.
     * 
     * @param machine
     *            StateMachine The state machine we're building.
     * @param startNode
     *            Node Node to search below.
     * @throws Exception
     */
    private void findTransitions(StateMachine machine, Node startNode)
            throws Exception {

        NodeList childNodes = startNode.getChildNodes();
        if (null != childNodes) {
            for (int i = 0; i < childNodes.getLength(); i++) {
                Node thisNode = childNodes.item(i);

                findTransitions(machine, thisNode);

                // Check if this is a proper transition specification node:
                if (isNodeName(thisNode, helper.uml().lit(UMLLabel.TAG_TRANSITION))
                        && helper.uml().prefixed(UMLLabel.TAG_TRANSITION).equalsIgnoreCase(
                                Util.getNodeAttribute(thisNode, XMIIdentifiers.type()))) {
                    Transition transition;
                    String id = Util.getNodeAttribute(thisNode, XMIIdentifiers.id());
                    try {
                        String sourceId = Util.getNodeAttribute(thisNode, helper.uml().lit(UMLLabel.KEY_SOURCE));
                        String targetId = Util.getNodeAttribute(thisNode, helper.uml().lit(UMLLabel.KEY_TARGET));

                        // Find an associated trigger event for this transition:
                        Object event = findTransitionTrigger(thisNode);
                        if (event == null) {
                            // No trigger found (perhaps an initial transition)...
                            transition = new Transition(id, null, sourceId, targetId);
                        } else if (event instanceof String) {
                            // The trigger is a string signal name:
                            transition = new Transition(id, (String) event, sourceId, targetId);
                        } else {
                            // The trigger is a transition timeout, so leave the
                            // signal name parameter null, and then add the
                            // timeout event object:
                            transition = new Transition(id, null, sourceId, targetId);
                            transition.add((TransitionTimeout) event);
                        }
                        // Check if this is an internal transition:
                        if (helper.uml().lit(UMLLabel.VAL_INTERNAL).equalsIgnoreCase(
                                Util.getNodeAttribute(thisNode, helper.uml().lit(UMLLabel.KEY_KIND)))) {
                            transition.setInternal();
                        }
                        // Get additional info related to this transition:
                        transition.add(findActions(thisNode, helper.uml().lit(UMLLabel.TAG_EFFECT)));
                        transition.add(findTransitionGuard(thisNode));
                        transition.add(getDiagramTransitionElement(transition, machine));
                        // Add this transition to the state machine:
                        machine.add(transition);
                    } catch (Exception e) {
                        System.err.println("*** Error processing transition (ID="
                                + id + ") in state machine " + machine.name()
                                + ": ");
                        throw e;
                    }
                }
            }
        }
    }

    /**
     * Recursively finds all state nodes, at and below the specified starting
     * node, and adds them to the specified state machine.
     * 
     * @param machine
     *            StateMachine The state machine we're building.
     * @param parentState
     *            State The parent state to the current state we're working on.
     * @param thisNode
     *            Node Starting node to search.
     * @throws Exception
     */
    private void findStates(StateMachine machine, State parentState,
            Node thisNode) throws Exception {

        // Check if the current node defines a state:
        State newState = convertToState(thisNode);

        checkNewState: if (null != newState) {
            // Yep, so process it...
            printNode(System.out, thisNode);

            // Set the state machine as it's owner
            newState.setEnclosingStateMachine(machine);

            // Check if this is new state is a composite state region, in which
            // case we need to do special processing:
            if (newState instanceof CompositeStateRegion) {
                // Transitions are defined as being contained within a region:
                // Make sure this is one of multiple regions within a
                // ConcurrentCompositeState:
                if (null == parentState
                        || !(parentState instanceof ConcurrentCompositeState)) {
                    // No, this is just a single region defined within a
                    // state, which we can discard:
                    break checkNewState;
                }
            }

            // A Submachine state may need special processing in order to
            // handle any of the ConnectionPoint references to it. We
            // handle these as external transitions
            if (newState instanceof SubmachineState) {
                // Fetch the submachine name
            }

            newState.addEntryAction(findActions(thisNode, helper.uml().lit(UMLLabel.TAG_ENTRY)));
            newState.addExitAction(findActions(thisNode, helper.uml().lit(UMLLabel.TAG_EXIT)));
            newState.addDuringAction(findActions(thisNode, helper.uml().lit(UMLLabel.TAG_DOACTIVITY)));
            findStateInsAndOuts(newState, thisNode, machine.transitions());
            newState.add(getDiagramStateElement(newState, machine));
            if (null == parentState) { // ...with no parent state
                machine.add(newState);
            } else {
                // machine.addStateName(newState.name(),
                // newState instanceof CompositeStateRegion);
                String path = parentState.name();
                State s = parentState.getParent();
                while (s != null) {
                    path = s.name() + ":" + path;
                    s = s.getParent();
                }

                ((CompositeState) parentState).addChild(newState);
            }
            newState.setParent(parentState);
            parentState = newState;
        }

        // Search all child nodes of this one for more states:
        NodeList childNodes = thisNode.getChildNodes();
        if (null != childNodes) {
            for (int i = 0; i < childNodes.getLength(); i++) {
                findStates(machine, parentState, childNodes.item(i));
            }
        }
    }

    /**
     * Finds incoming and outgoing transition definition nodes, and adds the
     * corresponding transitions to the specified state.
     * 
     * @param thisState
     *            State The state for which we're finding incoming and outgoing
     *            transitions.
     * @param startNode
     *            Node The node to search at and below.
     * @param transList
     *            List The list of transitions to correlate with the state's
     *            incomings and outgoings.
     */
    private void findStateInsAndOuts(State thisState, Node startNode,
            List<Transition> transList) throws Exception {
        helper.findStateInsAndOuts(thisState, startNode, transList);
    }

    /**
     * Check if specified node is a state definition of some sort, and if so,
     * return the corresponding State object. Otherwise return null.
     * 
     * @param thisNode
     *            Node Candidate state definition node.
     * @throws Exception
     * @return State New state object created from specified node, or null if
     *         not a valid state definition node.
     */
    private State convertToState(Node thisNode) throws Exception {

        // A legal state definition node must have the following attributes:
        if (null == thisNode
                || null == thisNode.getNodeName()
                || null == Util.getNodeAttribute(thisNode, XMIIdentifiers.id())
                || null == Util.getNodeAttribute(thisNode, XMIIdentifiers.type())) {
            return null;
        }
        State newState = null;

        // Get the node's name (if available):
        String name = Util.getNodeAttribute(thisNode, ReaderNamespaceContext.nameAttr());
        // Get the node's (required) id number string:
        String id = Util.getNodeAttribute(thisNode, XMIIdentifiers.id());

        // Now process the specific types of nodes which can define states:
        if (isNodeName(thisNode, helper.uml().lit(UMLLabel.TAG_SUBVERTEX))) {
            if (isNodeType(thisNode, helper.uml().prefixed(UMLLabel.TYPE_STATE))) {
                try {
                    List<Node> subRegions = new ArrayList<Node>();
                    findNodes(subRegions, helper.uml().lit(UMLLabel.TAG_REGION),
                            XMIIdentifiers.type(),
                            helper.uml().prefixed(UMLLabel.TYPE_REGION),
                            thisNode, 1);

                    if (subRegions.isEmpty()) {
                        // No subregion means a simple or submachine state.
                        if (null != thisNode.getAttributes().getNamedItem("submachine")) {
                            newState = new SubmachineState(name, id);
                            String submachineId = thisNode.getAttributes().getNamedItem("submachine").getNodeValue();
                            ((SubmachineState) newState).setSubmachine(submachineId);
                        } else {
                            newState = new SimpleState(name, id);
                        }
                    } else if (1 == subRegions.size()) {
                        // A single subregion means a composite state.
                        newState = new CompositeState(name, id);
                    } else {
                        // Multiple subregions means this is a concurrent
                        // composite state.
                        newState = new ConcurrentCompositeState(name, id);
                    }
                } catch (gov.nasa.jpl.statechart.core.SimpleState.NotNamedException e) {
                    // Discard any SimpleState (or subclass) which doesn't
                    // specify a name...
                }
            } else if (isNodeType(thisNode, helper.uml().prefixed(UMLLabel.TYPE_PSEUDOSTATE))) {
                String kind = Util.getNodeAttribute(thisNode, helper.uml().lit(UMLLabel.KEY_KIND));
                newState = helper.refinePseudoState(kind, name, id);
            } else if (isNodeType(thisNode, helper.uml().prefixed(UMLLabel.TYPE_FINALSTATE))) {
                newState = new FinalState(helper.makeUniqueName("Final"), id);
            }
        } else if (isNodeName(thisNode, helper.uml().lit(UMLLabel.TAG_REGION))) {
            newState = new CompositeStateRegion(name, id);
        } else if (isNodeName(thisNode, helper.uml().lit(UMLLabel.TAG_CONNECTION))) {
            List<Node> ids = new ArrayList<Node>();

            // System.out.println( "Creating new ConnectionPoint, id = " + id );
            newState = new ConnectionPointReference(name, id);

            // Find the pseudo states
            findNodes(ids, helper.uml().lit(UMLLabel.TAG_ENTRY), thisNode, 1);
            findNodes(ids, helper.uml().lit(UMLLabel.TAG_EXIT), thisNode, 1);

            if (ids.size() != 1) {
                System.out.println("Incorrect number of pseudo states found");
                System.exit(1);
            }

            Node pseudo = ids.get(0);
            String refId = Util.getNodeAttribute(pseudo, XMIIdentifiers.idref());

            // System.out.println( "Added link ID " + refId );
            ((ConnectionPointReference) newState).setLink(refId);
        }

        return newState;
    }

    private CoordinatePoint findWindowBounds(Node stateDiagramData) throws Exception {

        Node wbNode = findNode(helper.TAG_MD_DIAGRAM_WINDOW_BOUDNS, stateDiagramData, 2);
        if (null != wbNode && null != wbNode.getFirstChild()) {
            int[] wb = toIntArray((String) wbNode.getFirstChild().getNodeValue());
            if (null != wb) {
                return new CoordinatePoint((wb[2] - wb[0]), (wb[3] - wb[1]));
            }
        }
        return null;
    }

    /**
     * Searches one level of the subtree starting at the specified node, looking
     * for action specification nodes.
     * 
     * @param startNode
     *            Node Top of subtree below which to search.
     * @param nodeName
     *            String Optional name of node for which to search.
     * @return List Action nodes found, or null if none found.
     */
    private List<Action> findActions(Node startNode, String nodeName)
            throws Exception {
        NodeList childNodes = startNode.getChildNodes();
        if (childNodes == null) return null;
        
        List<Action> actions = new ArrayList<Action>();
        findActionNodes: for (int i = 0; i < childNodes.getLength(); i++) {
            Node nextNode = childNodes.item(i);
            if (null == nodeName || isNodeName(nextNode, nodeName)) {
                if (null == Util.getNodeAttribute(nextNode, XMIIdentifiers.type())
                        || !(isNodeType(nextNode, helper.uml().prefixed(UMLLabel.TAG_ACTIVITY))
                                || isNodeType(nextNode, helper.uml().prefixed(UMLLabel.TAG_INTERACTION)))) {
                    // This node is not a valid action specification...
                    continue findActionNodes;
                }
                // else, process "nextNode"
                printNode(System.out, nextNode);

                // Check if this node has a name attribute:
                String nameAttrValue = Util.getNodeAttribute(nextNode, ReaderNamespaceContext.nameAttr());
                if (nameAttrValue != null) {
                    // If the name attribute is specified, then it
                    // overrides any child action specification nodes:
                    if (isMethodCallSyntax(nameAttrValue)
                            || nameAttrValue.startsWith("\"")) {
                        actions.add(new CallAction(nameAttrValue));
                    } else if (null != findSignalWithAttr(ReaderNamespaceContext.nameAttr(), nameAttrValue)) {
                        actions.add(new EventAction(nameAttrValue));
                    } else {
                        throw new Exception(
                                "Invalid action specification \""
                                + nameAttrValue
                                + "\" must either conform to method call syntax, or be a known signal name.");
                    }
                } else {
                    // Since the name attribute wasn't specified, then
                    // look for child action specification nodes:
                    List<Node> actionNodes = new ArrayList<Node>();
                    findNodes(actionNodes, "",
                            XMIIdentifiers.type(),
                            helper.uml().prefixed("CallBehaviorAction"),
                            nextNode, 1);
                    findNodes(actionNodes, "",
                            XMIIdentifiers.type(),
                            helper.uml().prefixed("SendSignalAction"),
                            nextNode, 1);
                    for (Node nextAction : actionNodes) {
                        if (isNodeType(nextAction,
                                helper.uml().prefixed("CallBehaviorAction"))) {
                            String actionName = Util.getNodeAttribute(nextAction, ReaderNamespaceContext.nameAttr());
                            if (actionName != null) {
                                actions.add(new CallAction(actionName));
                            }
                        } else if (isNodeType(nextAction,
                                helper.uml().prefixed("SendSignalAction"))) {
                            String signalID = Util.getNodeAttribute(nextAction, helper.uml().lit(UMLLabel.KEY_SIGNAL));
                            if (signalID != null) {
                                Node signal = findSignalWithAttr(XMIIdentifiers.id(), signalID);
                                if (signal != null) {
                                    actions.add(new EventAction(Util.getNodeAttribute(signal, ReaderNamespaceContext.nameAttr())));
                                } else {
                                    throw new Exception(
                                            "Found uml:SendSignalAction with invalid signal ID="
                                            + signalID + ".");
                                }
                            }
                        }
                    }
                }
            }
        }
        return actions;
    }

    /**
     * Searches for node defining the GUI diagram element for the specified
     * state.
     * 
     * @param state
     *            State State object for which to find relevant diagram element.
     * @param machine
     *            StateMachine The state machine instance which has the lists of
     *            diagram nodes.
     * @return DiagramStateElement Diagram element for state, or null if not
     *         found.
     * @throws Exception
     */
    private DiagramStateElement getDiagramStateElement(State state,
            StateMachine machine) throws Exception {

        for (Node nextStateMdElementNode : machine.stateMdElementList()) {
            Node idrefNode = findNode(helper.TAG_MD_ELEMENT_ID,
                    XMIIdentifiers.idref(), state.id(),
                    nextStateMdElementNode, 1);
            if (null != idrefNode) {
                Node geometryNode = findNode(helper.TAG_MD_GEOMETRY,
                        nextStateMdElementNode, 1);
                if (null != geometryNode) {
                    // We have all the info needed to create a
                    // DiagramStateElement:
                    int[] intArray = toIntArray(geometryNode.getFirstChild().getNodeValue());
                    if (null != intArray && intArray.length == 4) {
                        // We have a good list of geometry points for this state
                        // view element.
                        CoordinatePoint p0 = new CoordinatePoint(intArray[0],
                                intArray[1]);
                        CoordinatePoint p1 = new CoordinatePoint(p0.x
                                + intArray[2], p0.y + intArray[3]);
                        // Pass in the machine as an argument so
                        // we can get fully-scoped names
                        DiagramStateElement result = new DiagramStateElement(
                                state, machine, p0, p1);
                        // Add fill color for diagram state element:
                        if (state instanceof InitialState
                                || state instanceof FinalState
                                || state instanceof JunctionState)
                            result.addFillColor(DiagramStateElement.defaultPseudostateFillColor);
                        else {
                            Node colorPropertyNode = findNode(helper.TAG_MD_ELEMENT,
                                    helper.KEY_ELEMENT_CLASS, "ColorProperty",
                                    nextStateMdElementNode, 2);
                            if (null != colorPropertyNode
                                    && null != findNode(helper.TAG_MD_PROPERTY_ID,
                                            colorPropertyNode, 1)
                                    && findNode(helper.TAG_MD_PROPERTY_ID,
                                            colorPropertyNode, 1).getFirstChild().getNodeValue().equalsIgnoreCase("FILL_COLOR")) {
                                Node valueNode = findNode(ReaderNamespaceContext.valueAttr(), XMIIdentifiers.value(),
                                        colorPropertyNode, 1);
                                String colorValStr = Util.getNodeAttribute(valueNode, XMIIdentifiers.value());
                                if (null != colorValStr) {
                                    int fillColor = Integer.parseInt(colorValStr);
                                    result.addFillColor(fillColor);
                                } else
                                    result.addFillColor(DiagramStateElement.defaultStateFillColor);
                            } else
                                result.addFillColor(DiagramStateElement.defaultStateFillColor);
                        }
                        return result;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Searches for node defining the GUI diagram element for the specified
     * transition.
     * 
     * @param transition
     *            Transition Transition object for which to find relevant
     *            diagram element.
     * @param machine
     *            StateMachine The state machine instance which has the lists of
     *            diagram nodes.
     * @return DiagramStateElement Diagram element for transition, or null if
     *         not found.
     * @throws Exception
     */
    private DiagramTransitionElement getDiagramTransitionElement(
            Transition transition, StateMachine machine) throws Exception {

        for (Node nextTransitionViewNode : machine.transitionMdElementList()) {
            boolean isSelfTransition = helper.MD_TRANSITION_TO_SELF.equals(
                    Util.getNodeAttribute(nextTransitionViewNode, helper.KEY_ELEMENT_CLASS));
            Node idrefNode = findNode(helper.TAG_MD_ELEMENT_ID,
                    XMIIdentifiers.idref(), transition.id(),
                    nextTransitionViewNode, 1);
            if (null != idrefNode) {
                Node geometryNode = findNode(helper.TAG_MD_GEOMETRY,
                        nextTransitionViewNode, 1);
                if (null != geometryNode) {
                    int[] intArray = toIntArray(geometryNode.getFirstChild().getNodeValue());
                    if (null != intArray) {
                        // We have a good list of geometry points for this state
                        // view element.
                        String name = transition.signalName();
                        if (null == name && null != transition.guard()) {
                            name = "[" + transition.guard().methodName() + "]";
                        }
                        DiagramTransitionElement result;
                        if (isSelfTransition)
                            result = new DiagramSelfTransitionElement(name);
                        else
                            result = new DiagramTransitionElement(name);
                        for (int x = 0; x < intArray.length; x += 2) {
                            CoordinatePoint p = new CoordinatePoint(
                                    intArray[x], intArray[x + 1]);
                            result.addPoint(p);
                        }
                        return result;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Searches through known transition events to associate one to the passed
     * trigger node.
     * 
     * @param thisNode
     *            Node Trigger node for which to find a matching trigger event.
     * @return Object A string signal name, a TransitionTimeout instance, or
     *         null if not found.
     */
    private Object findTransitionTrigger(Node thisNode) throws Exception {

        Node triggerNode = findNode(helper.uml().lit(UMLLabel.TAG_TRIGGER), helper.uml().lit(UMLLabel.KEY_EVENT), thisNode, 1);
        // Get the ID of the event which causes this transition:
        String triggerEventId = Util.getNodeAttribute(triggerNode, helper.uml().lit(UMLLabel.KEY_EVENT));
        if (triggerEventId == null) return null;

        // We have trigger event ID, go through the signal event list to find a match:
        for (Node nextSignalEvent : signalEventList) {
            if (Util.getNodeAttribute(nextSignalEvent,
                    XMIIdentifiers.id()).equals(triggerEventId)) {
                // The trigger event ID matches this signal event.
                String signalId = Util.getNodeAttribute(nextSignalEvent, helper.uml().lit(UMLLabel.KEY_SIGNAL));
                if (signalId != null) {
                    for (Node nextSignal : signalList) {
                        if (signalId.equals(Util.getNodeAttribute(nextSignal,
                                XMIIdentifiers.id()))) {
                            // Found the matching signal in the list, so
                            // make sure it has a name attribute specified:
                            String signalName = Util.getNodeAttribute(nextSignal, ReaderNamespaceContext.nameAttr());
                            if (signalName == null) return null;
                            // Else, we've found signal name!
//                            String visibility = XmiUtil.getNodeAttribute(nextSignal, "visibility");
                            helper.checkSafeEventOnTransition(thisNode, signalName.trim());
                            return signalName;
                        }
                    }
                } else {
                    String signalName = Util.getNodeAttribute(nextSignalEvent, ReaderNamespaceContext.nameAttr());
                    if (signalName != null) {
                        // This signal event just has the signal name defined as
                        // a name attribute, rather than as a link via ID to the
                        // signal definition node.
                        return signalName;
                    }
                }
            }
        }

        // We didn't find the trigger event ID in the signal event list, so
        // search for it in the timeout event list:
        for (Node nextTimeEvent : timeEventList) {
            String timeEventId = Util.getNodeAttribute(nextTimeEvent, XMIIdentifiers.id());
            if (triggerEventId.equals(timeEventId)) {
                // Found the matching timeout event. So get the timeout expression:
                return new TransitionTimeout(helper.getTimeOutExpression(nextTimeEvent));
            }
        }
        return null;
    }

    /**
     * Searches one level of the subtree starting at the specified node, looking
     * for a transition guard specification node.
     * 
     * @param startNode
     *            Node Starting node below which to search.
     * @return TransitionGuard Instance created from found guard expression, or
     *         null if not found.
     */
    private TransitionGuard findTransitionGuard(Node startNode)
            throws Exception {
        NodeList childNodes = startNode.getChildNodes();
        if (null != childNodes) {
            for (int i = 0; i < childNodes.getLength(); i++) {
                Node thisNode = childNodes.item(i);
                if (isNodeName(thisNode, helper.uml().lit(UMLLabel.TAG_GUARD))
                        && isNodeType(thisNode, helper.uml().prefixed(UMLLabel.TYPE_CONSTRAINT))) {
                    Node specNode = findNode(helper.uml().lit(UMLLabel.TAG_SPECIFICATION), thisNode, 1);
                    String guardText = Util.getNodeAttribute(specNode, helper.uml().lit(UMLLabel.KEY_BODY));
                    if (guardText == null) {
                        throw new Exception(
                                "Invalid XMI file formal - guard node (ID="
                                + Util.getNodeAttribute(specNode, XMIIdentifiers.id())
                                + ") found without a valid specification childnode");
                    } else {
                        // TODO CHECK correctness!  guardText length GREATER than 1?
                        if (guardText.length() > 1) {
                            return new TransitionGuard(guardText);
                        }
                    }
                }
            }
        }
        return null;
    }


    /**
     * Self-test routine for this class.
     * 
     * @param args  String[] XML file name(s) to parse.
     */
    public static void main(String[] args) {
        try {
            MagicDrawUmlReader r = new MagicDrawUmlReader();
            r.setDebug(true);

            /**
             * This parses the file starting with the top-level <xmi:xmi>
             * element. The signals are identified and extracted from the entire
             * file. [Could this cause problems if signals have the same name in
             * different diagrams?]. The signals are stored in a List<Node>.
             * 
             * After the signals are found, the parser finds the other
             * information via the abstract method findOtherModelInfo. This will
             * be over-written by seach XMI reader subclass. For the MagicDraw
             * reader, we find diagrams, signalEvents, and timeEvents.
             * 
             * Finally, we search for all the state machine definitions and
             * actually create and build the state machines. These StateMachine
             * objects are paired with their names and saved as a Map<String,
             * StateMachine> which is retrieved by the getStateMachineMap
             * method.
             */
            r.parseXmlFiles(args);

            for (StateMachine machine : r.getStateMachineMap().values()) {
                machine.print(System.out);
            }
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

}
