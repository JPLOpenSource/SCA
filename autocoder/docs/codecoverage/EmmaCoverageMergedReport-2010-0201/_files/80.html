<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Mon Feb 01 15:58:17 PST 2010)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="c.html">gov.nasa.jpl.statechart.input.magicdraw</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">MagicDrawReader.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>MagicDrawReader.java</TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>83%  (1061/1274)</TD><TD CLASS="h">80%  (213.5/267)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">MagicDrawReader</A></TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>83%  (1061/1274)</TD><TD CLASS="h">80%  (213.5/267)</TD></TR><TR><TD CLASS="f"><A HREF="#1">handleSpecificFormat (File): InputStream</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">32%  (27/85)</TD><TD CLASS="h">32%  (7/22)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">determineReaderVersion (Document): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">65%  (117/181)</TD><TD CLASS="h">61%  (25/41)</TD></TR><TR><TD CLASS="f"><A HREF="#3">getIntsAsPoints (String, String): List</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">74%  (34/46)</TD><TD CLASS="h">75%  (6/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">collectDiagramData (UMLModelGroup, UMLModel): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>81%  (132/162)</TD><TD>80%  (30.6/38)</TD></TR><TR><TD CLASS="f"><A HREF="#5">createUMLFromDOM (Document): UMLModel</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>85%  (35/41)</TD><TD CLASS="h">73%  (8/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">gatherTextboxes (Node, String, DiagramData): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>91%  (105/116)</TD><TD>91%  (21/23)</TD></TR><TR><TD CLASS="f"><A HREF="#7">gatherDiagramForElements (Node, DiagramData): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>92%  (347/378)</TD><TD>89%  (63/71)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">gatherSeparators (Node, String, DiagramData): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>99%  (99/100)</TD><TD>100% (18/18)</TD></TR><TR><TD CLASS="f"><A HREF="#0">MagicDrawReader (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (15/15)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">gatherDiagramForMachine (Node, Node, String, DiagramData): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (140/140)</TD><TD>100% (28/28)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getNSAttribute (Node, String): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/**</TD></TR><TR><TD CLASS="l">2</TD><TD> * Created Jul 24, 2009.</TD></TR><TR><TD CLASS="l">3</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">4</TD><TD> * Copyright 2009, by the California Institute of Technology. ALL RIGHTS</TD></TR><TR><TD CLASS="l">5</TD><TD> * RESERVED. United States Government Sponsorship acknowledged. Any commercial</TD></TR><TR><TD CLASS="l">6</TD><TD> * use must be negotiated with the Office of Technology Transfer at the</TD></TR><TR><TD CLASS="l">7</TD><TD> * California Institute of Technology.</TD></TR><TR><TD CLASS="l">8</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">9</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">10</TD><TD> * This software is subject to U.S. export control laws and regulations and has</TD></TR><TR><TD CLASS="l">11</TD><TD> * been classified as 4D993. By accepting this software, the user agrees to</TD></TR><TR><TD CLASS="l">12</TD><TD> * comply with all applicable U.S. export laws and regulations. User has the</TD></TR><TR><TD CLASS="l">13</TD><TD> * responsibility to obtain export licenses, or other export authority as may be</TD></TR><TR><TD CLASS="l">14</TD><TD> * required before exporting such information to foreign countries or providing</TD></TR><TR><TD CLASS="l">15</TD><TD> * access to foreign persons.</TD></TR><TR><TD CLASS="l">16</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">17</TD><TD> */</TD></TR><TR><TD CLASS="l">18</TD><TD>package gov.nasa.jpl.statechart.input.magicdraw;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>import gov.nasa.jpl.statechart.Timer;</TD></TR><TR><TD CLASS="l">21</TD><TD>import gov.nasa.jpl.statechart.Util;</TD></TR><TR><TD CLASS="l">22</TD><TD>import gov.nasa.jpl.statechart.input.AbstractXmiReader;</TD></TR><TR><TD CLASS="l">23</TD><TD>import gov.nasa.jpl.statechart.input.identifiers.UMLIdentifiers;</TD></TR><TR><TD CLASS="l">24</TD><TD>import gov.nasa.jpl.statechart.input.identifiers.UMLLabel;</TD></TR><TR><TD CLASS="l">25</TD><TD>import gov.nasa.jpl.statechart.input.identifiers.XMIIdentifiers;</TD></TR><TR><TD CLASS="l">26</TD><TD>import gov.nasa.jpl.statechart.input.identifiers.XMILabel;</TD></TR><TR><TD CLASS="l">27</TD><TD>import gov.nasa.jpl.statechart.input.validator.FatalModelException;</TD></TR><TR><TD CLASS="l">28</TD><TD>import gov.nasa.jpl.statechart.model.UMLModelGroup;</TD></TR><TR><TD CLASS="l">29</TD><TD>import gov.nasa.jpl.statechart.model.diagram.DiagramData;</TD></TR><TR><TD CLASS="l">30</TD><TD>import gov.nasa.jpl.statechart.model.diagram.DiagramElement;</TD></TR><TR><TD CLASS="l">31</TD><TD>import gov.nasa.jpl.statechart.model.diagram.MachineElement;</TD></TR><TR><TD CLASS="l">32</TD><TD>import gov.nasa.jpl.statechart.model.diagram.SeparatorElement;</TD></TR><TR><TD CLASS="l">33</TD><TD>import gov.nasa.jpl.statechart.model.diagram.TextElement;</TD></TR><TR><TD CLASS="l">34</TD><TD>import gov.nasa.jpl.statechart.model.diagram.TransitionElement;</TD></TR><TR><TD CLASS="l">35</TD><TD>import gov.nasa.jpl.statechart.model.diagram.TransitionToSelfElement;</TD></TR><TR><TD CLASS="l">36</TD><TD>import gov.nasa.jpl.statechart.model.diagram.VertexElement;</TD></TR><TR><TD CLASS="l">37</TD><TD>import gov.nasa.jpl.statechart.uml.StateMachine;</TD></TR><TR><TD CLASS="l">38</TD><TD>import gov.nasa.jpl.statechart.uml.UMLElement;</TD></TR><TR><TD CLASS="l">39</TD><TD>import gov.nasa.jpl.statechart.uml.UMLModel;</TD></TR><TR><TD CLASS="l">40</TD><TD> </TD></TR><TR><TD CLASS="l">41</TD><TD>import java.awt.Point;</TD></TR><TR><TD CLASS="l">42</TD><TD>import java.io.File;</TD></TR><TR><TD CLASS="l">43</TD><TD>import java.io.FileInputStream;</TD></TR><TR><TD CLASS="l">44</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">45</TD><TD>import java.io.InputStream;</TD></TR><TR><TD CLASS="l">46</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">47</TD><TD>import java.util.Enumeration;</TD></TR><TR><TD CLASS="l">48</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">49</TD><TD>import java.util.zip.ZipEntry;</TD></TR><TR><TD CLASS="l">50</TD><TD>import java.util.zip.ZipFile;</TD></TR><TR><TD CLASS="l">51</TD><TD> </TD></TR><TR><TD CLASS="l">52</TD><TD>import javax.xml.XMLConstants;</TD></TR><TR><TD CLASS="l">53</TD><TD>import javax.xml.xpath.XPathConstants;</TD></TR><TR><TD CLASS="l">54</TD><TD>import javax.xml.xpath.XPathExpressionException;</TD></TR><TR><TD CLASS="l">55</TD><TD> </TD></TR><TR><TD CLASS="l">56</TD><TD>import org.w3c.dom.Document;</TD></TR><TR><TD CLASS="l">57</TD><TD>import org.w3c.dom.Element;</TD></TR><TR><TD CLASS="l">58</TD><TD>import org.w3c.dom.Node;</TD></TR><TR><TD CLASS="l">59</TD><TD>import org.w3c.dom.NodeList;</TD></TR><TR><TD CLASS="l">60</TD><TD> </TD></TR><TR><TD CLASS="l">61</TD><TD>/**</TD></TR><TR><TD CLASS="l">62</TD><TD> * This class provides the common data and methods for all MagicDraw</TD></TR><TR><TD CLASS="l">63</TD><TD> * UML reader versions to parse descriptions of UML state machines from XMI</TD></TR><TR><TD CLASS="l">64</TD><TD> * files generated by the MagicDraw UML tool. The parser creates a model of the</TD></TR><TR><TD CLASS="l">65</TD><TD> * state chart by building StateMachine objects containing States, Transitions,</TD></TR><TR><TD CLASS="l">66</TD><TD> * etc. The state chart model can then be used to generate an implementation in</TD></TR><TR><TD CLASS="l">67</TD><TD> * a language such as C/C++, Python, etc.</TD></TR><TR><TD CLASS="l">68</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">69</TD><TD> * N.B.:  As this was abstracted from readers of two MagicDraw versions, 12.5</TD></TR><TR><TD CLASS="l">70</TD><TD> * and 16.0, some shifting of functionalities between the super- and subclasses</TD></TR><TR><TD CLASS="l">71</TD><TD> * may be in order.</TD></TR><TR><TD CLASS="l">72</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">73</TD><TD> *</TD></TR><TR><TD CLASS="l">74</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">75</TD><TD> * Copyright &amp;copy; 2009 Jet Propulsion Lab / California Institute of Technology</TD></TR><TR><TD CLASS="l">76</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">77</TD><TD> *</TD></TR><TR><TD CLASS="l">78</TD><TD> * @author Shang-Wen Cheng &lt;scheng@jpl.nasa.gov&gt;, adapted from old MagicDrawUmlReader.</TD></TR><TR><TD CLASS="l">79</TD><TD> *</TD></TR><TR><TD CLASS="l">80</TD><TD> */</TD></TR><TR><TD CLASS="l">81</TD><TD>public class MagicDrawReader extends AbstractXmiReader {</TD></TR><TR><TD CLASS="l">82</TD><TD> </TD></TR><TR><TD CLASS="l">83</TD><TD>    /** The native packed MagicDraw format. */</TD></TR><TR><TD CLASS="l">84</TD><TD>    public static final String EXT_MDZIP = &#34;mdzip&#34;;</TD></TR><TR><TD CLASS="l">85</TD><TD>    /** The XMI XML file format. */</TD></TR><TR><TD CLASS="l">86</TD><TD>    public static final String EXT_XML = &#34;xml&#34;;</TD></TR><TR><TD CLASS="l">87</TD><TD>    /** The MDXML file format, which is equivalent to the XML format. */</TD></TR><TR><TD CLASS="l">88</TD><TD>    public static final String EXT_MDXML = &#34;mdxml&#34;;</TD></TR><TR><TD CLASS="l">89</TD><TD> </TD></TR><TR><TD CLASS="l">90</TD><TD> </TD></TR><TR><TD CLASS="l">91</TD><TD>    // Version-based identifiers</TD></TR><TR CLASS="c"><TD CLASS="l">92</TD><TD>    private MagicDrawIdentifiers mdId = null;</TD></TR><TR CLASS="c"><TD CLASS="l">93</TD><TD>    private XMIIdentifiers xmiId = null;</TD></TR><TR CLASS="c"><TD CLASS="l">94</TD><TD>    private UMLIdentifiers umlId = null;</TD></TR><TR><TD CLASS="l">95</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="0">96</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">97</TD><TD>     * Default constructor, initializes basic data structures.</TD></TR><TR><TD CLASS="l">98</TD><TD>     */</TD></TR><TR><TD CLASS="l">99</TD><TD>    public MagicDrawReader () {</TD></TR><TR CLASS="c"><TD CLASS="l">100</TD><TD>        super();</TD></TR><TR><TD CLASS="l">101</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">102</TD><TD>        mdId = MagicDrawIdentifiers.inst();</TD></TR><TR CLASS="c"><TD CLASS="l">103</TD><TD>    }</TD></TR><TR><TD CLASS="l">104</TD><TD> </TD></TR><TR><TD CLASS="l">105</TD><TD>    </TD></TR><TR><TD CLASS="l">106</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l">107</TD><TD>     * @see gov.nasa.jpl.statechart.input.AbstractXmiReader#handleSpecificFormat(java.io.File)</TD></TR><TR><TD CLASS="l"><A NAME="1">108</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">109</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">110</TD><TD>    protected InputStream handleSpecificFormat (File file) throws IOException{</TD></TR><TR><TD CLASS="l">111</TD><TD>        // get file's name and find its extension</TD></TR><TR CLASS="c"><TD CLASS="l">112</TD><TD>        String fname = file.getName();</TD></TR><TR CLASS="c"><TD CLASS="l">113</TD><TD>        String ext = &#34;&#34;;</TD></TR><TR CLASS="c"><TD CLASS="l">114</TD><TD>        int extIdx = fname.lastIndexOf(&#34;.&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">115</TD><TD>        if (extIdx &gt; -1) {</TD></TR><TR CLASS="c"><TD CLASS="l">116</TD><TD>            ext = fname.substring(extIdx+1);</TD></TR><TR><TD CLASS="l">117</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">118</TD><TD>        if (ext.equalsIgnoreCase(EXT_XML) ||</TD></TR><TR CLASS="z"><TD CLASS="l">119</TD><TD>                ext.equalsIgnoreCase(EXT_MDXML)) {</TD></TR><TR><TD CLASS="l">120</TD><TD>            // perfect, just return file as input stream</TD></TR><TR CLASS="c"><TD CLASS="l">121</TD><TD>            return new FileInputStream(file);</TD></TR><TR CLASS="z"><TD CLASS="l">122</TD><TD>        } else if (ext.equalsIgnoreCase(EXT_MDZIP)) {</TD></TR><TR><TD CLASS="l">123</TD><TD>            // OK, need to unzip first, then return contained file as input stream</TD></TR><TR CLASS="z"><TD CLASS="l">124</TD><TD>            ZipFile mdZip = new ZipFile(file);</TD></TR><TR CLASS="z"><TD CLASS="l">125</TD><TD>            Enumeration&lt;? extends ZipEntry&gt; entries = mdZip.entries();</TD></TR><TR><TD CLASS="l">126</TD><TD>            // just to make sure, let's find the mdxml file, assuming just 1!!</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>            ZipEntry mdXmlEntry = null;</TD></TR><TR CLASS="z"><TD CLASS="l">128</TD><TD>            while (entries.hasMoreElements()) {</TD></TR><TR CLASS="z"><TD CLASS="l">129</TD><TD>                ZipEntry ze = entries.nextElement();</TD></TR><TR CLASS="z"><TD CLASS="l">130</TD><TD>                if (ze.getName().endsWith(EXT_MDXML)) {  // found!</TD></TR><TR CLASS="z"><TD CLASS="l">131</TD><TD>                    mdXmlEntry = ze;</TD></TR><TR CLASS="z"><TD CLASS="l">132</TD><TD>                    break;</TD></TR><TR><TD CLASS="l">133</TD><TD>                }</TD></TR><TR><TD CLASS="l">134</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">135</TD><TD>            if (mdXmlEntry != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">136</TD><TD>                return mdZip.getInputStream(mdXmlEntry);</TD></TR><TR><TD CLASS="l">137</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">138</TD><TD>            throw new FatalModelException(&#34;FATAL: Failed to find a .&#34; + EXT_MDXML</TD></TR><TR><TD CLASS="l">139</TD><TD>                    + &#34; file in the supplied .&#34; + EXT_MDZIP + &#34; file!&#34;);</TD></TR><TR><TD CLASS="l">140</TD><TD>        } else {  // we don't understand this format, should bail!</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>            throw new FatalModelException(&#34;FATAL: File format '&#34; + ext</TD></TR><TR CLASS="z"><TD CLASS="l">142</TD><TD>                    + &#34;' NOT supported by the MagicDrawReader!&#34;);</TD></TR><TR><TD CLASS="l">143</TD><TD>        }</TD></TR><TR><TD CLASS="l">144</TD><TD>    }</TD></TR><TR><TD CLASS="l">145</TD><TD> </TD></TR><TR><TD CLASS="l">146</TD><TD> </TD></TR><TR><TD CLASS="l">147</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l">148</TD><TD>     * @see gov.nasa.jpl.statechart.input.AbstractXmiReader#determineReaderVersion(org.w3c.dom.Document)</TD></TR><TR><TD CLASS="l"><A NAME="2">149</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">150</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">151</TD><TD>    protected boolean determineReaderVersion (Document doc) {</TD></TR><TR><TD CLASS="l">152</TD><TD>        // Look for the xmi:Documentation tag to find exporter and exporterVerion tags</TD></TR><TR CLASS="c"><TD CLASS="l">153</TD><TD>        Element top = doc.getDocumentElement();</TD></TR><TR><TD CLASS="l">154</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">155</TD><TD>        if (!top.getLocalName().equals(XMILabel.TAG_XMI.defaultLiteral())) {</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>            Util.error(&#34;This is not an XMI document&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">158</TD><TD>        }</TD></TR><TR><TD CLASS="l">159</TD><TD>        // otherwise, set XMI namespace version</TD></TR><TR CLASS="c"><TD CLASS="l">160</TD><TD>        XMIIdentifiers.setNamespace(getNSAttribute(top, XMIIdentifiers.XMINS_PREFIX_DEFAULT));</TD></TR><TR><TD CLASS="l">161</TD><TD>        // get the corresponding identifier instance</TD></TR><TR CLASS="c"><TD CLASS="l">162</TD><TD>        xmiId = XMIIdentifiers.inst();</TD></TR><TR><TD CLASS="l">163</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">164</TD><TD>        NodeList docNodes = doc.getElementsByTagNameNS(xmiId.lit(XMILabel.XMI_NS), xmiId.lit(XMILabel.TAG_DOCUMENTATION));  </TD></TR><TR CLASS="c"><TD CLASS="l">165</TD><TD>        if (docNodes.getLength() != 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">166</TD><TD>            Util.error(&#34;No XMI Documentation tag found!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">168</TD><TD>        }</TD></TR><TR><TD CLASS="l">169</TD><TD>        // found XMI's Documentation tag, there should be only 1!</TD></TR><TR CLASS="c"><TD CLASS="l">170</TD><TD>        Element docNode = (Element) docNodes.item(0);</TD></TR><TR CLASS="c"><TD CLASS="l">171</TD><TD>        boolean foundMatch = false;  // did we find a matching version?</TD></TR><TR CLASS="c"><TD CLASS="l">172</TD><TD>        String lastVerTried = null;</TD></TR><TR CLASS="c"><TD CLASS="l">173</TD><TD>        if (docNode.getAttribute(xmiId.lit(XMILabel.KEY_EXPORTER)).equals(mdId.lit(MagicDrawLabel.EXPORTER))) {</TD></TR><TR CLASS="c"><TD CLASS="l">174</TD><TD>            String docExporterVer = docNode.getAttribute(xmiId.lit(XMILabel.KEY_EXPORTER_VERSION));</TD></TR><TR CLASS="c"><TD CLASS="l">175</TD><TD>            VERLOOP: for (String ver : MagicDrawIdentifiers.getSupportedVersions()) {</TD></TR><TR CLASS="c"><TD CLASS="l">176</TD><TD>                switch (Util.compareVersions(docExporterVer, ver)) {</TD></TR><TR><TD CLASS="l">177</TD><TD>                case 0:  // matched version!</TD></TR><TR CLASS="c"><TD CLASS="l">178</TD><TD>                    MagicDrawIdentifiers.setVersion(ver);</TD></TR><TR CLASS="c"><TD CLASS="l">179</TD><TD>                    foundMatch = true;</TD></TR><TR CLASS="c"><TD CLASS="l">180</TD><TD>                    break VERLOOP;</TD></TR><TR><TD CLASS="l">181</TD><TD> </TD></TR><TR><TD CLASS="l">182</TD><TD>                case -1:  // doc requires lower version than &#34;ver&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">183</TD><TD>                    if (lastVerTried == null) {</TD></TR><TR><TD CLASS="l">184</TD><TD>                        // no choice but to use our lowest supported version</TD></TR><TR CLASS="z"><TD CLASS="l">185</TD><TD>                        MagicDrawIdentifiers.setVersion(ver);</TD></TR><TR><TD CLASS="l">186</TD><TD>                    } else {</TD></TR><TR><TD CLASS="l">187</TD><TD>                        // we fall back to using our last found version</TD></TR><TR CLASS="z"><TD CLASS="l">188</TD><TD>                        MagicDrawIdentifiers.setVersion(lastVerTried);</TD></TR><TR><TD CLASS="l">189</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">190</TD><TD>                    foundMatch = true;</TD></TR><TR CLASS="z"><TD CLASS="l">191</TD><TD>                    break VERLOOP;</TD></TR><TR><TD CLASS="l">192</TD><TD> </TD></TR><TR><TD CLASS="l">193</TD><TD>                case 1:  // doc requires higher version, remember our &#34;ver&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">194</TD><TD>                    lastVerTried = ver;</TD></TR><TR><TD CLASS="l">195</TD><TD>                }</TD></TR><TR><TD CLASS="l">196</TD><TD>            }</TD></TR><TR><TD CLASS="l">197</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">198</TD><TD>        if (foundMatch) {  // set identifier instances for namespace version</TD></TR><TR CLASS="c"><TD CLASS="l">199</TD><TD>            mdId = MagicDrawIdentifiers.inst();</TD></TR><TR CLASS="c"><TD CLASS="l">200</TD><TD>            UMLIdentifiers.setNamespace(getNSAttribute(top, UMLIdentifiers.UMLNS_PREFIX_DEFAULT));</TD></TR><TR CLASS="c"><TD CLASS="l">201</TD><TD>            umlId = UMLIdentifiers.inst();</TD></TR><TR CLASS="c"><TD CLASS="l">202</TD><TD>            xmiId.setPrefix(doc.lookupPrefix(xmiId.lit(XMILabel.XMI_NS)));</TD></TR><TR CLASS="c"><TD CLASS="l">203</TD><TD>            umlId.setPrefix(doc.lookupPrefix(umlId.lit(UMLLabel.UML_NS)));</TD></TR><TR CLASS="c"><TD CLASS="l">204</TD><TD>            if (Util.isInfoLevel()) {</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>                Util.info(&#34;Input reader selected: &#34; + mdId.lit(MagicDrawLabel.EXPORTER)</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                        + &#34; ver. &#34; + mdId.version());</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>                Util.info(&#34;Namespace version selected for XMI is &#34; + xmiId.version()</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>                        + &#34; and UML is &#34; + umlId.version());</TD></TR><TR><TD CLASS="l">209</TD><TD>            }</TD></TR><TR><TD CLASS="l">210</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">211</TD><TD>            Util.error(&#34;Autocoder's reader currently supports only MagicDraw UML versions &#34;</TD></TR><TR CLASS="z"><TD CLASS="l">212</TD><TD>                    + Arrays.toString(MagicDrawIdentifiers.getSupportedVersions().toArray()));</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>            System.exit(-1);</TD></TR><TR><TD CLASS="l">214</TD><TD>        }</TD></TR><TR><TD CLASS="l">215</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="b">216</A></TD><TD>        return foundMatch;</TD></TR><TR><TD CLASS="l">217</TD><TD>    }</TD></TR><TR><TD CLASS="l">218</TD><TD> </TD></TR><TR><TD CLASS="l">219</TD><TD>    private String getNSAttribute (Node node, String attrName) {</TD></TR><TR CLASS="c"><TD CLASS="l">220</TD><TD>        return Util.getNodeAttribute(node, XMLConstants.XMLNS_ATTRIBUTE + &#34;:&#34; + attrName);</TD></TR><TR><TD CLASS="l">221</TD><TD>    }</TD></TR><TR><TD CLASS="l">222</TD><TD> </TD></TR><TR><TD CLASS="l">223</TD><TD> </TD></TR><TR><TD CLASS="l">224</TD><TD>    /**</TD></TR><TR><TD CLASS="l">225</TD><TD>     * Creates our internal representation of the UML Model from a</TD></TR><TR><TD CLASS="l">226</TD><TD>     * MagicDraw XMI DOM, starting with the UML:Model XMI Node contained in</TD></TR><TR><TD CLASS="l">227</TD><TD>     * the top-level xmi:xmi node.</TD></TR><TR><TD CLASS="l">228</TD><TD>     * </TD></TR><TR><TD CLASS="l">229</TD><TD>     * @see gov.nasa.jpl.statechart.input.AbstractXmiReader#createUMLFromDOM(org.w3c.dom.Document)</TD></TR><TR><TD CLASS="l"><A NAME="5">230</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">231</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">232</TD><TD>    protected UMLModel createUMLFromDOM (Document document) {</TD></TR><TR><TD CLASS="l">233</TD><TD>        // At this point, document should already be verified to be XMI.</TD></TR><TR CLASS="c"><TD CLASS="l">234</TD><TD>        UMLModel model = null;</TD></TR><TR CLASS="c"><TD CLASS="l">235</TD><TD>        if (document != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">236</TD><TD>            Element top = document.getDocumentElement();</TD></TR><TR><TD CLASS="l">237</TD><TD> </TD></TR><TR><TD CLASS="l">238</TD><TD>            // Look for any &lt;uml:Model&gt; tags</TD></TR><TR CLASS="c"><TD CLASS="l">239</TD><TD>            NodeList umlNodes = top.getElementsByTagNameNS(umlId.lit(UMLLabel.UML_NS), umlId.lit(UMLLabel.TAG_MODEL));</TD></TR><TR CLASS="c"><TD CLASS="l">240</TD><TD>            if (umlNodes.getLength() == 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>                Util.error(&#34;No UML Models found!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>                return null;</TD></TR><TR><TD CLASS="l">243</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">244</TD><TD>            if (umlNodes.getLength() &gt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">245</TD><TD>                Util.warn(&#34;Found more than one model. Ignoring the rest!&#34;);</TD></TR><TR><TD CLASS="l">246</TD><TD>            }</TD></TR><TR><TD CLASS="l">247</TD><TD> </TD></TR><TR><TD CLASS="l">248</TD><TD>            // Construct our internal UML meta-model</TD></TR><TR CLASS="c"><TD CLASS="l">249</TD><TD>            model = new UMLModel(UMLModel.gatherStats(umlNodes.item(0)));</TD></TR><TR><TD CLASS="l">250</TD><TD>        }</TD></TR><TR><TD CLASS="l">251</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">252</TD><TD>        return model;</TD></TR><TR><TD CLASS="l">253</TD><TD>    }</TD></TR><TR><TD CLASS="l">254</TD><TD> </TD></TR><TR><TD CLASS="l">255</TD><TD> </TD></TR><TR><TD CLASS="l">256</TD><TD>    /* (non-Javadoc)</TD></TR><TR><TD CLASS="l"><A NAME="4">257</A></TD><TD>     * @see gov.nasa.jpl.statechart.input.AbstractXmiReader#collectDiagramData(gov.nasa.jpl.statechart.model.UMLModelGroup, gov.nasa.jpl.statechart.uml.UMLModel)</TD></TR><TR><TD CLASS="l">258</TD><TD>     */</TD></TR><TR><TD CLASS="l">259</TD><TD>    @Override</TD></TR><TR><TD CLASS="l">260</TD><TD>    protected void collectDiagramData (UMLModelGroup modelGrp, UMLModel model) {</TD></TR><TR CLASS="c"><TD CLASS="l">261</TD><TD>        Document doc = modelGrp.getDocument(model);</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>        if (doc == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">263</TD><TD>            Util.error(&#34;Fata! Null Document object (shouldn't be!), could not collect diagram data.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">264</TD><TD>            return;</TD></TR><TR><TD CLASS="l">265</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">266</TD><TD>        Timer timer = new Timer();</TD></TR><TR CLASS="c"><TD CLASS="l">267</TD><TD>        System.out.println(&#34;Collecting Diagram data...&#34;);</TD></TR><TR><TD CLASS="l">268</TD><TD> </TD></TR><TR><TD CLASS="l">269</TD><TD>        // create and store Diagram info map.</TD></TR><TR CLASS="c"><TD CLASS="l">270</TD><TD>        DiagramData data = new DiagramData();</TD></TR><TR CLASS="c"><TD CLASS="l">271</TD><TD>        modelGrp.mapModelToDiagramData(model, data);</TD></TR><TR><TD CLASS="l">272</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">273</TD><TD>        Element top = doc.getDocumentElement();</TD></TR><TR CLASS="c"><TD CLASS="l">274</TD><TD>        for (StateMachine machine : model.getStateMachines()) {</TD></TR><TR><TD CLASS="l">275</TD><TD>            try {</TD></TR><TR><TD CLASS="l">276</TD><TD>                // get root of diagram MD element: xmi:Extension/mdOwnedDiagrams/mdElement/mdElement </TD></TR><TR CLASS="c"><TD CLASS="l">277</TD><TD>                Node diagramElement = (Node) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">278</TD><TD>                        xmiId.prefixed(XMILabel.TAG_EXTENSION) + &#34;/&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">279</TD><TD>                        + mdId.lit(MagicDrawLabel.TAG_OWNED_DIAGRAMS) + &#34;/&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">280</TD><TD>                        + mdId.lit(MagicDrawLabel.TAG_ELEMENT) + &#34;[@&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">281</TD><TD>                             + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">282</TD><TD>                             + &#34;='Diagram' and @&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">283</TD><TD>                             + mdId.lit(MagicDrawLabel.KEY_DIAGRAM_OWNER)</TD></TR><TR CLASS="c"><TD CLASS="l">284</TD><TD>                             + &#34;='&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">285</TD><TD>                             + machine.id()</TD></TR><TR CLASS="c"><TD CLASS="l">286</TD><TD>                             +&#34;']/&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>                         + mdId.lit(MagicDrawLabel.TAG_ELEMENT),</TD></TR><TR CLASS="c"><TD CLASS="l">288</TD><TD>                        top,</TD></TR><TR CLASS="c"><TD CLASS="l">289</TD><TD>                        XPathConstants.NODE);</TD></TR><TR CLASS="c"><TD CLASS="l">290</TD><TD>                if (diagramElement == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">291</TD><TD>                    Util.error(&#34;Diagram element NOT found for machine &#34; + machine.getQualifiedName() + &#34;?!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">292</TD><TD>                    continue;</TD></TR><TR><TD CLASS="l">293</TD><TD>                }</TD></TR><TR><TD CLASS="l">294</TD><TD>                //- also get ownedViews node as root of element geometry</TD></TR><TR CLASS="c"><TD CLASS="l">295</TD><TD>                Node ownedViews = (Node) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">296</TD><TD>                        mdId.lit(MagicDrawLabel.TAG_OWNED_VIEWS),</TD></TR><TR CLASS="c"><TD CLASS="l">297</TD><TD>                        diagramElement, XPathConstants.NODE);</TD></TR><TR><TD CLASS="l">298</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">299</TD><TD>                gatherDiagramForMachine(diagramElement, ownedViews, machine.id(), data);</TD></TR><TR><TD CLASS="l">300</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">301</TD><TD>                gatherDiagramForElements(ownedViews, data);</TD></TR><TR><TD CLASS="l">302</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">303</TD><TD>                gatherSeparators(ownedViews, machine.id(), data);</TD></TR><TR><TD CLASS="l">304</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">305</TD><TD>                gatherTextboxes(ownedViews, machine.id(), data);</TD></TR><TR><TD CLASS="l">306</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">307</TD><TD>            } catch (XPathExpressionException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">308</TD><TD>                e.printStackTrace();</TD></TR><TR><TD CLASS="l">309</TD><TD>            }</TD></TR><TR><TD CLASS="l">310</TD><TD>        }</TD></TR><TR><TD CLASS="l">311</TD><TD> </TD></TR><TR CLASS="p"><TD TITLE="18% line coverage (2 out of 11 instructions)" CLASS="l">312</TD><TD TITLE="18% line coverage (2 out of 11 instructions)">        if (Util.isDebugLevel()) Util.debug(&#34;Diagram data aquired! &#34; + data.toString());</TD></TR><TR CLASS="p"><TD TITLE="40% line coverage (2 out of 5 instructions)" CLASS="l">313</TD><TD TITLE="40% line coverage (2 out of 5 instructions)">        if (Util.isInfoLevel()) timer.markTime();</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>    }</TD></TR><TR><TD CLASS="l">315</TD><TD> </TD></TR><TR><TD CLASS="l">316</TD><TD>    /**</TD></TR><TR><TD CLASS="l">317</TD><TD>     * Finds diagram window info for the machine, looking under XPath</TD></TR><TR><TD CLASS="l">318</TD><TD>     * mdOwnedViews/mdElement.</TD></TR><TR><TD CLASS="l">319</TD><TD>     * </TD></TR><TR><TD CLASS="l">320</TD><TD>     * @param diagramElement  root XMI Node to look for window bounds </TD></TR><TR><TD CLASS="l">321</TD><TD>     * @param ownedViews  XMI Node for mdOwnedViews</TD></TR><TR><TD CLASS="l">322</TD><TD>     * @param smId  ID of StateMachine, used to storing mapping</TD></TR><TR><TD CLASS="l">323</TD><TD>     * @param data  DiagramData for storing gathered data </TD></TR><TR><TD CLASS="l"><A NAME="a">324</A></TD><TD>     * @throws XPathExpressionException</TD></TR><TR><TD CLASS="l">325</TD><TD>     */</TD></TR><TR><TD CLASS="l">326</TD><TD>    private void gatherDiagramForMachine (Node diagramElement, Node ownedViews, String smId, DiagramData data)</TD></TR><TR><TD CLASS="l">327</TD><TD>    throws XPathExpressionException {</TD></TR><TR CLASS="c"><TD CLASS="l">328</TD><TD>        String windowBoundsStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">329</TD><TD>                mdId.lit(MagicDrawLabel.TAG_DIAGRAM_WINDOW_BOUNDS),</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>                diagramElement, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">331</TD><TD>        String zoomFactorStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">332</TD><TD>                mdId.lit(MagicDrawLabel.TAG_ZOOM_FACTOR) + &#34;/@&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">333</TD><TD>                + XMIIdentifiers.value(),</TD></TR><TR CLASS="c"><TD CLASS="l">334</TD><TD>                diagramElement, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">335</TD><TD>        String frameGeometryStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">336</TD><TD>                mdId.lit(MagicDrawLabel.TAG_ELEMENT) + &#34;[@&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">337</TD><TD>                    + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_DIAGRAM_FRAME)</TD></TR><TR CLASS="c"><TD CLASS="l">339</TD><TD>                    + &#34;']/&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">340</TD><TD>                + mdId.lit(MagicDrawLabel.TAG_GEOMETRY),</TD></TR><TR CLASS="c"><TD CLASS="l">341</TD><TD>                ownedViews, XPathConstants.STRING);</TD></TR><TR><TD CLASS="l">342</TD><TD>        // construct machine's diagram element object</TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>        int[] coordInts = toIntArray(frameGeometryStr);</TD></TR><TR CLASS="c"><TD CLASS="l">344</TD><TD>        MachineElement mElem = new MachineElement(smId);</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        for (int i=0; i &lt; coordInts.length; i+=2) {</TD></TR><TR CLASS="c"><TD CLASS="l">346</TD><TD>            Point p = new Point(coordInts[i], coordInts[i+1]);</TD></TR><TR CLASS="c"><TD CLASS="l">347</TD><TD>            mElem.addPoint(p);</TD></TR><TR><TD CLASS="l">348</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">349</TD><TD>        if (zoomFactorStr != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">350</TD><TD>            mElem.setZoomFactor(Double.parseDouble(zoomFactorStr));</TD></TR><TR><TD CLASS="l">351</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>        if (windowBoundsStr != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">353</TD><TD>            coordInts = toIntArray(windowBoundsStr);</TD></TR><TR CLASS="c"><TD CLASS="l">354</TD><TD>            if (coordInts.length &gt;= 4) {</TD></TR><TR CLASS="c"><TD CLASS="l">355</TD><TD>                mElem.setWindowBounds(new Point(coordInts[0], coordInts[1]),</TD></TR><TR CLASS="c"><TD CLASS="l">356</TD><TD>                        new Point(coordInts[2], coordInts[3]));</TD></TR><TR><TD CLASS="l">357</TD><TD>            }</TD></TR><TR><TD CLASS="l">358</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">359</TD><TD>        data.elementMap.put(smId, mElem);</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>    }</TD></TR><TR><TD CLASS="l">361</TD><TD> </TD></TR><TR><TD CLASS="l">362</TD><TD>    /**</TD></TR><TR><TD CLASS="l">363</TD><TD>     * Gather diagram nodes for State, Pseudostate, Transition (incl. to self),</TD></TR><TR><TD CLASS="l">364</TD><TD>     * and Decision (Junction states)</TD></TR><TR><TD CLASS="l">365</TD><TD>     * </TD></TR><TR><TD CLASS="l">366</TD><TD>     * @param ownedViews  XMI node under which to search for element diagram data</TD></TR><TR><TD CLASS="l">367</TD><TD>     * @param data  DiagramData for storing gathered data </TD></TR><TR><TD CLASS="l">368</TD><TD>     * @throws XPathExpressionException  in case of unexpected error in XPath eval</TD></TR><TR><TD CLASS="l"><A NAME="7">369</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">370</TD><TD>    private void gatherDiagramForElements (Node ownedViews, DiagramData data)</TD></TR><TR><TD CLASS="l">371</TD><TD>    throws XPathExpressionException {</TD></TR><TR><TD CLASS="l">372</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">373</TD><TD>        NodeList diagramNodes = (NodeList) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>                &#34;.//&#34; + mdId.lit(MagicDrawLabel.TAG_ELEMENT)</TD></TR><TR CLASS="c"><TD CLASS="l">375</TD><TD>                    + &#34;[@&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">376</TD><TD>                    + &#34;='&#34; + umlId.lit(UMLLabel.TYPE_REGION)</TD></TR><TR CLASS="c"><TD CLASS="l">377</TD><TD>                    + &#34;' or @&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">378</TD><TD>                    + &#34;='&#34; + umlId.lit(UMLLabel.TYPE_STATE)</TD></TR><TR CLASS="c"><TD CLASS="l">379</TD><TD>                    + &#34;' or @&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_DECISION)</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>                    + &#34;' or @&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">382</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_PSEUDOSTATE)</TD></TR><TR CLASS="c"><TD CLASS="l">383</TD><TD>                    + &#34;' or @&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">384</TD><TD>                    + &#34;='&#34; + umlId.lit(UMLLabel.TYPE_TRANSITION)</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>                    + &#34;' or @&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">386</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_TRANSITION_TO_SELF)</TD></TR><TR CLASS="c"><TD CLASS="l">387</TD><TD>                    + &#34;']&#34;,</TD></TR><TR CLASS="c"><TD CLASS="l">388</TD><TD>                ownedViews,</TD></TR><TR CLASS="c"><TD CLASS="l">389</TD><TD>                XPathConstants.NODESET);</TD></TR><TR CLASS="c"><TD CLASS="l">390</TD><TD>        for (int i=0; i &lt; diagramNodes.getLength(); ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">391</TD><TD>            Node dNode = diagramNodes.item(i);</TD></TR><TR><TD CLASS="l">392</TD><TD>            // obtain element class</TD></TR><TR CLASS="c"><TD CLASS="l">393</TD><TD>            String elementClass = Util.getNodeAttribute(dNode, mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS));</TD></TR><TR><TD CLASS="l">394</TD><TD>            // grab element refid</TD></TR><TR CLASS="c"><TD CLASS="l">395</TD><TD>            String elementID = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">396</TD><TD>                    mdId.lit(MagicDrawLabel.TAG_ELEMENT_ID) + &#34;/@&#34; + XMIIdentifiers.idref(),</TD></TR><TR CLASS="c"><TD CLASS="l">397</TD><TD>                    dNode, XPathConstants.STRING);</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR><TD CLASS="l">399</TD><TD>            // grab and parse geometry values into array of points</TD></TR><TR CLASS="c"><TD CLASS="l">400</TD><TD>            String geometryStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">401</TD><TD>                    mdId.lit(MagicDrawLabel.TAG_GEOMETRY),</TD></TR><TR CLASS="c"><TD CLASS="l">402</TD><TD>                    dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">403</TD><TD>            List&lt;Point&gt; points = getIntsAsPoints(geometryStr, &#34;Element ID &#34; + elementID);</TD></TR><TR CLASS="p"><TD TITLE="98% line coverage (53 out of 54 instructions)" CLASS="l">404</TD><TD TITLE="98% line coverage (53 out of 54 instructions)">            if (points == null) continue;</TD></TR><TR><TD CLASS="l">405</TD><TD> </TD></TR><TR><TD CLASS="l">406</TD><TD>            // construct the diagram element object</TD></TR><TR CLASS="c"><TD CLASS="l">407</TD><TD>            DiagramElement dElem = null;</TD></TR><TR CLASS="c"><TD CLASS="l">408</TD><TD>            if (elementClass == null) {  // something wrong?</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>                Util.error(&#34;A diagram node found with unknown elementClass!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">410</TD><TD>                continue;</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>            } else if (elementClass.equals(umlId.lit(UMLLabel.TYPE_TRANSITION))) {</TD></TR><TR CLASS="c"><TD CLASS="l">412</TD><TD>                dElem = new TransitionElement(elementID);</TD></TR><TR CLASS="c"><TD CLASS="l">413</TD><TD>                for (Point p : points) {</TD></TR><TR CLASS="c"><TD CLASS="l">414</TD><TD>                    dElem.addPoint(p);</TD></TR><TR><TD CLASS="l">415</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">416</TD><TD>            } else if (elementClass.equals(mdId.lit(MagicDrawLabel.MD_TRANSITION_TO_SELF))) {</TD></TR><TR><TD CLASS="l">417</TD><TD>                /* special treatment for self-transitions:</TD></TR><TR><TD CLASS="l">418</TD><TD>                 * - toSelf flag is set to true</TD></TR><TR><TD CLASS="l">419</TD><TD>                 * - pair of points are origin of arrow and width/height of box</TD></TR><TR><TD CLASS="l">420</TD><TD>                 * - &#34;edge&#34; is needed to determine whether horizontal or vertical</TD></TR><TR><TD CLASS="l">421</TD><TD>                 */</TD></TR><TR CLASS="c"><TD CLASS="l">422</TD><TD>                dElem = new TransitionToSelfElement(elementID);</TD></TR><TR><TD CLASS="l">423</TD><TD>                // fetch and store the 'edge' element</TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>                String edgeStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>                        mdId.lit(MagicDrawLabel.TAG_EDGE) + &#34;/@&#34; + XMIIdentifiers.value(),</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>                        dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">427</TD><TD>                ((TransitionToSelfElement) dElem).setEdge(Integer.parseInt(edgeStr));</TD></TR><TR><TD CLASS="l">428</TD><TD>                // store points</TD></TR><TR CLASS="c"><TD CLASS="l">429</TD><TD>                for (Point p : points) {</TD></TR><TR CLASS="c"><TD CLASS="l">430</TD><TD>                    dElem.addPoint(p);</TD></TR><TR><TD CLASS="l">431</TD><TD>                }</TD></TR><TR><TD CLASS="l">432</TD><TD>            } else {  // remaining possibilities are State or Pseudostate!</TD></TR><TR><TD CLASS="l">433</TD><TD>                // assume two points</TD></TR><TR CLASS="c"><TD CLASS="l">434</TD><TD>                VertexElement vElem = new VertexElement(elementID, points.get(0), points.get(1));</TD></TR><TR CLASS="c"><TD CLASS="l">435</TD><TD>                if (elementClass.equals(mdId.lit(MagicDrawLabel.MD_PSEUDOSTATE))</TD></TR><TR CLASS="c"><TD CLASS="l">436</TD><TD>                        || elementClass.equals(mdId.lit(MagicDrawLabel.MD_DECISION))) {</TD></TR><TR><TD CLASS="l">437</TD><TD>                    // set a default color</TD></TR><TR CLASS="c"><TD CLASS="l">438</TD><TD>                    vElem.setOutlineColor(VertexElement.defaultPseudostateFillColor);</TD></TR><TR><TD CLASS="l">439</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>                    int fillColor = VertexElement.defaultStateFillColor;</TD></TR><TR><TD CLASS="l">441</TD><TD> </TD></TR><TR><TD CLASS="l">442</TD><TD>                    // grab color property</TD></TR><TR CLASS="c"><TD CLASS="l">443</TD><TD>                    Node colorPropNode = (Node) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">444</TD><TD>                            mdId.lit(MagicDrawLabel.TAG_PROPERTIES) + &#34;/&#34;</TD></TR><TR CLASS="c"><TD CLASS="l">445</TD><TD>                                + mdId.lit(MagicDrawLabel.TAG_ELEMENT)</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>                                + &#34;[@&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">447</TD><TD>                                + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_COLOR_PROPERTY)</TD></TR><TR CLASS="c"><TD CLASS="l">448</TD><TD>                                + &#34;']&#34;,</TD></TR><TR CLASS="c"><TD CLASS="l">449</TD><TD>                            dNode, XPathConstants.NODE);</TD></TR><TR CLASS="c"><TD CLASS="l">450</TD><TD>                    if (colorPropNode != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">451</TD><TD>                        String propID = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">452</TD><TD>                                mdId.lit(MagicDrawLabel.TAG_PROPERTY_ID),</TD></TR><TR CLASS="c"><TD CLASS="l">453</TD><TD>                                dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">454</TD><TD>                        if (mdId.lit(MagicDrawLabel.VALUE_FILL_COLOR).equals(propID)) {</TD></TR><TR CLASS="z"><TD CLASS="l">455</TD><TD>                            String colorProp = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>                                    mdId.lit(MagicDrawLabel.TAG_VALUE)</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>                                        + &#34;/@&#34; + XMIIdentifiers.value(),</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                                    dNode, XPathConstants.STRING);</TD></TR><TR CLASS="z"><TD CLASS="l">459</TD><TD>                            if (colorProp != null &amp;&amp; colorProp.length() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                                fillColor = Integer.parseInt(colorProp);</TD></TR><TR><TD CLASS="l">461</TD><TD>                            }</TD></TR><TR><TD CLASS="l">462</TD><TD>                        }</TD></TR><TR><TD CLASS="l">463</TD><TD>                    }</TD></TR><TR CLASS="c"><TD CLASS="l">464</TD><TD>                    vElem.setOutlineColor(fillColor);</TD></TR><TR><TD CLASS="l">465</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">466</TD><TD>                dElem = vElem;</TD></TR><TR><TD CLASS="l">467</TD><TD>            }</TD></TR><TR><TD CLASS="l">468</TD><TD>            // store in map</TD></TR><TR CLASS="c"><TD CLASS="l">469</TD><TD>            data.elementMap.put(elementID, dElem);</TD></TR><TR><TD CLASS="l">470</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">471</TD><TD>    }</TD></TR><TR><TD CLASS="l">472</TD><TD> </TD></TR><TR><TD CLASS="l">473</TD><TD>    /**</TD></TR><TR><TD CLASS="l">474</TD><TD>     * Finds region separator diagram info.</TD></TR><TR><TD CLASS="l">475</TD><TD>     * @param ownedViews  XMI node under which to search for separators</TD></TR><TR><TD CLASS="l">476</TD><TD>     * @param data  DiagramData for storing gathered data </TD></TR><TR><TD CLASS="l">477</TD><TD>     * @throws XPathExpressionException  in case of unexpected error in XPath eval</TD></TR><TR><TD CLASS="l"><A NAME="8">478</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">479</TD><TD>    private void gatherSeparators (Node ownedViews, String smId, DiagramData data)</TD></TR><TR><TD CLASS="l">480</TD><TD>    throws XPathExpressionException {</TD></TR><TR><TD CLASS="l">481</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">482</TD><TD>        NodeList diagramNodes = (NodeList) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">483</TD><TD>                &#34;.//&#34; + mdId.lit(MagicDrawLabel.TAG_ELEMENT)</TD></TR><TR CLASS="c"><TD CLASS="l">484</TD><TD>                    + &#34;[@&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">485</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_SPLIT) + &#34;']&#34;,</TD></TR><TR CLASS="c"><TD CLASS="l">486</TD><TD>                ownedViews, XPathConstants.NODESET);</TD></TR><TR CLASS="c"><TD CLASS="l">487</TD><TD>        for (int i=0; i &lt; diagramNodes.getLength(); ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">488</TD><TD>            Node dNode = diagramNodes.item(i);</TD></TR><TR><TD CLASS="l">489</TD><TD>            // get geometry and construct elem</TD></TR><TR CLASS="c"><TD CLASS="l">490</TD><TD>            String geometryStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">491</TD><TD>                    mdId.lit(MagicDrawLabel.TAG_GEOMETRY),</TD></TR><TR CLASS="c"><TD CLASS="l">492</TD><TD>                    dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">493</TD><TD>            List&lt;Point&gt; points = getIntsAsPoints(geometryStr, &#34;Separator &#34; + dNode.getNodeName());</TD></TR><TR CLASS="p"><TD TITLE="97% line coverage (28 out of 29 instructions)" CLASS="l">494</TD><TD TITLE="97% line coverage (28 out of 29 instructions)">            if (points == null) continue;</TD></TR><TR><TD CLASS="l">495</TD><TD> </TD></TR><TR><TD CLASS="l">496</TD><TD>            // got two coordinate points, now add new separator element</TD></TR><TR CLASS="c"><TD CLASS="l">497</TD><TD>            List&lt;SeparatorElement&gt; sepElems = data.separatorElementMap.get(smId);</TD></TR><TR CLASS="c"><TD CLASS="l">498</TD><TD>            if (sepElems == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">499</TD><TD>                sepElems = Util.newList();</TD></TR><TR CLASS="c"><TD CLASS="l">500</TD><TD>                data.separatorElementMap.put(smId, sepElems);</TD></TR><TR><TD CLASS="l">501</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>            sepElems.add(new SeparatorElement(points.get(0), points.get(1)));</TD></TR><TR><TD CLASS="l">503</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">504</TD><TD>    }</TD></TR><TR><TD CLASS="l">505</TD><TD> </TD></TR><TR><TD CLASS="l">506</TD><TD>    /**</TD></TR><TR><TD CLASS="l">507</TD><TD>     * Finds text box diagram info.</TD></TR><TR><TD CLASS="l">508</TD><TD>     * @param ownedViews  XMI node under which to search for textboxes</TD></TR><TR><TD CLASS="l">509</TD><TD>     * @param data  DiagramData for storing gathered data </TD></TR><TR><TD CLASS="l">510</TD><TD>     * @throws XPathExpressionException  in case of unexpected error in XPath eval</TD></TR><TR><TD CLASS="l"><A NAME="6">511</A></TD><TD>     */</TD></TR><TR><TD CLASS="l">512</TD><TD>    private void gatherTextboxes (Node ownedViews, String smId, DiagramData data)</TD></TR><TR><TD CLASS="l">513</TD><TD>    throws XPathExpressionException {</TD></TR><TR><TD CLASS="l">514</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">515</TD><TD>        NodeList diagramNodes = (NodeList) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">516</TD><TD>                &#34;.//&#34; + mdId.lit(MagicDrawLabel.TAG_ELEMENT)</TD></TR><TR CLASS="c"><TD CLASS="l">517</TD><TD>                    + &#34;[@&#34; + mdId.lit(MagicDrawLabel.KEY_ELEMENT_CLASS)</TD></TR><TR CLASS="c"><TD CLASS="l">518</TD><TD>                    + &#34;='&#34; + mdId.lit(MagicDrawLabel.MD_TEXTBOX) + &#34;']&#34;,</TD></TR><TR CLASS="c"><TD CLASS="l">519</TD><TD>                ownedViews, XPathConstants.NODESET);</TD></TR><TR CLASS="c"><TD CLASS="l">520</TD><TD>        for (int i=0; i &lt; diagramNodes.getLength(); ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">521</TD><TD>            Node dNode = diagramNodes.item(i);</TD></TR><TR><TD CLASS="l">522</TD><TD>            // get geometry and text to construct elem</TD></TR><TR CLASS="c"><TD CLASS="l">523</TD><TD>            String geometryStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">524</TD><TD>                    mdId.lit(MagicDrawLabel.TAG_GEOMETRY),</TD></TR><TR CLASS="c"><TD CLASS="l">525</TD><TD>                    dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">526</TD><TD>            String txtStr = (String) UMLElement.xpath.evaluate(</TD></TR><TR CLASS="c"><TD CLASS="l">527</TD><TD>                    mdId.lit(MagicDrawLabel.TAG_TEXT),</TD></TR><TR CLASS="c"><TD CLASS="l">528</TD><TD>                    dNode, XPathConstants.STRING);</TD></TR><TR CLASS="c"><TD CLASS="l">529</TD><TD>            int[] coordInts = toIntArray(geometryStr);</TD></TR><TR CLASS="c"><TD CLASS="l">530</TD><TD>            if (coordInts.length &lt; 2) {</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>                Util.error(&#34;Warning: Textbox for '&#34; + txtStr + &#34;' specified incomplete coordinates!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">532</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">533</TD><TD>            }</TD></TR><TR><TD CLASS="l">534</TD><TD> </TD></TR><TR><TD CLASS="l">535</TD><TD>            // got pair of coordinate dims, now add new text element</TD></TR><TR CLASS="c"><TD CLASS="l">536</TD><TD>            List&lt;TextElement&gt; txtElems = data.textElementMap.get(smId);</TD></TR><TR CLASS="c"><TD CLASS="l">537</TD><TD>            if (txtElems == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">538</TD><TD>                txtElems = Util.newList();</TD></TR><TR CLASS="c"><TD CLASS="l">539</TD><TD>                data.textElementMap.put(smId, txtElems);</TD></TR><TR><TD CLASS="l">540</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">541</TD><TD>            txtElems.add(new TextElement(txtStr, new Point(coordInts[0], coordInts[1])));</TD></TR><TR><TD CLASS="l"><A NAME="3">542</A></TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">543</TD><TD>    }</TD></TR><TR><TD CLASS="l">544</TD><TD> </TD></TR><TR><TD CLASS="l">545</TD><TD>    private List&lt;Point&gt; getIntsAsPoints (String geometryStr, String errSrc) {</TD></TR><TR CLASS="c"><TD CLASS="l">546</TD><TD>        int[] coordInts = toIntArray(geometryStr);</TD></TR><TR CLASS="c"><TD CLASS="l">547</TD><TD>        if (coordInts.length &lt; 4) {  // something wrong</TD></TR><TR CLASS="z"><TD CLASS="l">548</TD><TD>            Util.error(&#34;Warning: &#34; + errSrc + &#34; specified incomplete geometric coordinates (fewer than 4 integers)!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">549</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">550</TD><TD>        }</TD></TR><TR><TD CLASS="l">551</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">552</TD><TD>        List&lt;Point&gt; points = Util.newList();</TD></TR><TR CLASS="c"><TD CLASS="l">553</TD><TD>        for (int j=0; j &lt; coordInts.length; j+=2) {</TD></TR><TR CLASS="c"><TD CLASS="l">554</TD><TD>            points.add(new Point(coordInts[j], coordInts[j+1]));</TD></TR><TR><TD CLASS="l">555</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">556</TD><TD>        return points;</TD></TR><TR><TD CLASS="l">557</TD><TD>    }</TD></TR><TR><TD CLASS="l">558</TD><TD> </TD></TR><TR><TD CLASS="l">559</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="c.html">gov.nasa.jpl.statechart.input.magicdraw</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>