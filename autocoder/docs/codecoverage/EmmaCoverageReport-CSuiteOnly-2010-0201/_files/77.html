<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Mon Feb 01 15:58:17 PST 2010)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="a.html">gov.nasa.jpl.statechart</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">Autocoder.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>Autocoder.java</TD><TD>100% (1/1)</TD><TD CLASS="h">69%  (20/29)</TD><TD CLASS="h">50%  (524/1039)</TD><TD CLASS="h">51%  (124.2/245)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">Autocoder</A></TD><TD>100% (1/1)</TD><TD CLASS="h">69%  (20/29)</TD><TD CLASS="h">50%  (524/1039)</TD><TD CLASS="h">51%  (124.2/245)</TD></TR><TR><TD CLASS="f"><A HREF="#1">allowDupSMName (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/3)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">ignoreDuplicateXmiIds (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#3">printUsageAndExit (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/200)</TD><TD CLASS="h">0%   (0/43)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">printVersionAndExit (): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/30)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="f"><A HREF="#5">qualifySignals (): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/13)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#6">setDebugOn (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#7">setDupSMName (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">setNoTrace (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR><TD CLASS="f"><A HREF="#9">setVerbose (boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/4)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">specificSMRequested (String): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">16%  (8/49)</TD><TD CLASS="h">23%  (3/13)</TD></TR><TR><TD CLASS="f"><A HREF="#b">isExecutionTraceOn (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">53%  (9/17)</TD><TD CLASS="h">58%  (1.8/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#c">isDebugOn (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">56%  (5/9)</TD><TD CLASS="h">55%  (0.6/1)</TD></TR><TR><TD CLASS="f"><A HREF="#d">generate (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">59%  (57/96)</TD><TD CLASS="h">52%  (12/23)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#e">processCommandArguments (String []): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">60%  (128/215)</TD><TD CLASS="h">53%  (26/49)</TD></TR><TR><TD CLASS="f"><A HREF="#f">filterTransitionEvents (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">60%  (6/10)</TD><TD CLASS="h">60%  (0.6/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#10">init (String []): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">68%  (94/139)</TD><TD CLASS="h">72%  (18.6/26)</TD></TR><TR><TD CLASS="f"><A HREF="#11">ifDefineMain (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">71%  (5/7)</TD><TD CLASS="h">71%  (0.7/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#12">autocodingTarget (): IGenerator$Kind</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">78%  (7/9)</TD><TD CLASS="h">67%  (2/3)</TD></TR><TR><TD CLASS="f"><A HREF="#13">dispose (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>84%  (38/45)</TD><TD>82%  (9/11)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">&lt;static initializer&gt;</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (34/34)</TD><TD>100% (9/9)</TD></TR><TR><TD CLASS="f"><A HREF="#15">Autocoder (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (70/70)</TD><TD>100% (21/21)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#16">findGenerators (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (28/28)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#17">inst (): Autocoder</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (3/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#18">isImplCallLive (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#19">isVerbose (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1a">main (String []): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (5/5)</TD></TR><TR><TD CLASS="f"><A HREF="#1b">setImplCall (boolean): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1c">signalGenRequested (): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1d">version (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (2/2)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>/**</TD></TR><TR><TD CLASS="l">2</TD><TD> * Created Aug 5, 2009.</TD></TR><TR><TD CLASS="l">3</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">4</TD><TD> * Copyright 2009, by the California Institute of Technology. ALL RIGHTS</TD></TR><TR><TD CLASS="l">5</TD><TD> * RESERVED. United States Government Sponsorship acknowledged. Any commercial</TD></TR><TR><TD CLASS="l">6</TD><TD> * use must be negotiated with the Office of Technology Transfer at the</TD></TR><TR><TD CLASS="l">7</TD><TD> * California Institute of Technology.</TD></TR><TR><TD CLASS="l">8</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">9</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">10</TD><TD> * This software is subject to U.S. export control laws and regulations and has</TD></TR><TR><TD CLASS="l">11</TD><TD> * been classified as 4D993. By accepting this software, the user agrees to</TD></TR><TR><TD CLASS="l">12</TD><TD> * comply with all applicable U.S. export laws and regulations. User has the</TD></TR><TR><TD CLASS="l">13</TD><TD> * responsibility to obtain export licenses, or other export authority as may be</TD></TR><TR><TD CLASS="l">14</TD><TD> * required before exporting such information to foreign countries or providing</TD></TR><TR><TD CLASS="l">15</TD><TD> * access to foreign persons.</TD></TR><TR><TD CLASS="l">16</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">17</TD><TD> */</TD></TR><TR><TD CLASS="l">18</TD><TD>package gov.nasa.jpl.statechart;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>import gov.nasa.jpl.statechart.autocode.GeneratorKind;</TD></TR><TR><TD CLASS="l">21</TD><TD>import gov.nasa.jpl.statechart.autocode.IGenerator;</TD></TR><TR><TD CLASS="l">22</TD><TD>import gov.nasa.jpl.statechart.autocode.IWriter;</TD></TR><TR><TD CLASS="l">23</TD><TD>import gov.nasa.jpl.statechart.autocode.IGenerator.Kind;</TD></TR><TR><TD CLASS="l">24</TD><TD>import gov.nasa.jpl.statechart.input.IReader;</TD></TR><TR><TD CLASS="l">25</TD><TD>import gov.nasa.jpl.statechart.input.validator.FatalModelException;</TD></TR><TR><TD CLASS="l">26</TD><TD>import gov.nasa.jpl.statechart.template.TargetLanguageMapper;</TD></TR><TR><TD CLASS="l">27</TD><TD> </TD></TR><TR><TD CLASS="l">28</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">29</TD><TD>import java.util.Arrays;</TD></TR><TR><TD CLASS="l">30</TD><TD>import java.util.Calendar;</TD></TR><TR><TD CLASS="l">31</TD><TD>import java.util.HashMap;</TD></TR><TR><TD CLASS="l">32</TD><TD>import java.util.LinkedHashMap;</TD></TR><TR><TD CLASS="l">33</TD><TD>import java.util.LinkedHashSet;</TD></TR><TR><TD CLASS="l">34</TD><TD>import java.util.LinkedList;</TD></TR><TR><TD CLASS="l">35</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">36</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">37</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">38</TD><TD> </TD></TR><TR><TD CLASS="l">39</TD><TD>/**</TD></TR><TR><TD CLASS="l">40</TD><TD> * The main class for invoking autocoders and querying system configurations.</TD></TR><TR><TD CLASS="l">41</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">42</TD><TD> * Copyright &amp;copy; 2009 Jet Propulsion Lab / California Institute of Technology</TD></TR><TR><TD CLASS="l">43</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l"><A NAME="0">44</A></TD><TD> * @author Shang-Wen Cheng &lt;scheng@jpl.nasa.gov&gt;</TD></TR><TR><TD CLASS="l">45</TD><TD> *</TD></TR><TR><TD CLASS="l">46</TD><TD> */</TD></TR><TR CLASS="c"><TD CLASS="l">47</TD><TD>public class Autocoder {</TD></TR><TR CLASS="c"><TD CLASS="l">48</TD><TD>    public static final String AC_VERSION = version();</TD></TR><TR><TD CLASS="l">49</TD><TD>    public static final String AC_COPYRIGHTS = &#34;Copyright (C) 2009-%d California Institute of Technology&#34;;</TD></TR><TR><TD CLASS="l">50</TD><TD> </TD></TR><TR><TD CLASS="l">51</TD><TD>    public static final String OPT_NO_TRACE = &#34;-notrace&#34;;</TD></TR><TR><TD CLASS="l">52</TD><TD>    public static final String OPT_QUALIFY_SIGNALS = &#34;-qualify-signals&#34;;</TD></TR><TR><TD CLASS="l">53</TD><TD>    public static final String OPT_IGNORE_DUP_IDS = &#34;-ignore-dup-ids&#34;;</TD></TR><TR><TD CLASS="l">54</TD><TD> </TD></TR><TR><TD CLASS="l">55</TD><TD>    /** Used for C/C++, flag defined to turn on stamping out the Main code. */</TD></TR><TR><TD CLASS="l">56</TD><TD>    public static final String FLAG_DEFINE_MAIN = &#34;DEFINE_MAIN&#34;;</TD></TR><TR><TD CLASS="l">57</TD><TD> </TD></TR><TR><TD CLASS="l">58</TD><TD>    public static final String PROP_NO_TRACE = &#34;jpl.autocode.noTrace&#34;;</TD></TR><TR><TD CLASS="l">59</TD><TD>    public static final String PROP_QUALIFY_SIGNALS = &#34;jpl.autocode.qualifySignals&#34;;</TD></TR><TR><TD CLASS="l">60</TD><TD>    public static final String PROP_IGNORE_DUP_IDS = &#34;jpl.autocode.ignoreDuplicateXmiIDs&#34;;</TD></TR><TR><TD CLASS="l">61</TD><TD>    public static final String PROP_TARGET_C = &#34;jpl.autocode.c&#34;;</TD></TR><TR><TD CLASS="l">62</TD><TD> </TD></TR><TR><TD CLASS="l">63</TD><TD>    public static final String OPT_USAGE = &#34;-h&#34;;</TD></TR><TR><TD CLASS="l">64</TD><TD>    public static final String OPT_DUP_SM = &#34;-dup-smnames&#34;;</TD></TR><TR><TD CLASS="l">65</TD><TD>    // TODO get rid of impl call flag now?!</TD></TR><TR><TD CLASS="l">66</TD><TD>    public static final String OPT_IMPL_CALLS = &#34;-implcalls&#34;;</TD></TR><TR><TD CLASS="l">67</TD><TD>    public static final String OPT_STATE_MACHINE = &#34;-sm&#34;;</TD></TR><TR><TD CLASS="l">68</TD><TD>    public static final String OPT_VERBOSE = &#34;-verbose&#34;;</TD></TR><TR><TD CLASS="l">69</TD><TD>    public static final String OPT_DEBUG = &#34;-debug&#34;;</TD></TR><TR><TD CLASS="l">70</TD><TD>    public static final String OPT_VERSION = &#34;-version&#34;;</TD></TR><TR><TD CLASS="l">71</TD><TD> </TD></TR><TR><TD CLASS="l">72</TD><TD>    /** Map of option to kinds of Generator supported by this Autocoder */</TD></TR><TR CLASS="c"><TD CLASS="l">73</TD><TD>    private static final Map&lt;String,Kind&gt; opt2GenKindMap = new LinkedHashMap&lt;String,Kind&gt;();</TD></TR><TR><TD CLASS="l">74</TD><TD>    static {</TD></TR><TR CLASS="c"><TD CLASS="l">75</TD><TD>        opt2GenKindMap.put(&#34;-python&#34;, Kind.Python);</TD></TR><TR CLASS="c"><TD CLASS="l">76</TD><TD>        opt2GenKindMap.put(&#34;-c&#34;, Kind.C);</TD></TR><TR CLASS="c"><TD CLASS="l">77</TD><TD>        opt2GenKindMap.put(&#34;-cpp&#34;, Kind.Cpp);</TD></TR><TR CLASS="c"><TD CLASS="l">78</TD><TD>        opt2GenKindMap.put(&#34;-promela&#34;, Kind.Promela);</TD></TR><TR CLASS="c"><TD CLASS="l">79</TD><TD>        opt2GenKindMap.put(&#34;-signals&#34;, Kind.Signals);</TD></TR><TR><TD CLASS="l">80</TD><TD>//        opt2GenKindMap.put(&#34;-c-adhoc&#34;, Kind.CNonTemplate);</TD></TR><TR><TD CLASS="l">81</TD><TD>//        opt2GenKindMap.put(&#34;-expython&#34;, Kind.ExPython);</TD></TR><TR><TD CLASS="l">82</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="17">83</A></TD><TD> </TD></TR><TR><TD CLASS="l">84</TD><TD>    /** Singleton instance of the Autocoder application object */</TD></TR><TR CLASS="c"><TD CLASS="l">85</TD><TD>    private static Autocoder singleton = null;</TD></TR><TR><TD CLASS="l">86</TD><TD>    public static Autocoder inst () {</TD></TR><TR CLASS="c"><TD CLASS="l">87</TD><TD>        if (singleton == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">88</TD><TD>            singleton = new Autocoder();</TD></TR><TR><TD CLASS="l">89</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="1d">90</A></TD><TD>        return singleton;</TD></TR><TR><TD CLASS="l">91</TD><TD>    }</TD></TR><TR><TD CLASS="l">92</TD><TD> </TD></TR><TR><TD CLASS="l">93</TD><TD>    private static String version () {</TD></TR><TR CLASS="c"><TD CLASS="l">94</TD><TD>        return &#34;2.1 beta (build 20100126-1230)&#34;; // released, major Velocity refactoring</TD></TR><TR><TD CLASS="l">95</TD><TD>//        return &#34;2.1 beta (build 20100113-1930)&#34;; // promoted</TD></TR><TR><TD CLASS="l">96</TD><TD>//        return &#34;2.1 beta (build 20091230-1320)&#34;; // promoted</TD></TR><TR><TD CLASS="l">97</TD><TD>//        return &#34;2.1 beta (build 20091215-1030)&#34;; // promoted</TD></TR><TR><TD CLASS="l">98</TD><TD>//        return &#34;2.1 beta (build 20091210-1300)&#34;; // promoted</TD></TR><TR><TD CLASS="l">99</TD><TD>//        return &#34;2.1 beta (build 20091202-1300)&#34;; // promoted</TD></TR><TR><TD CLASS="l">100</TD><TD>//        return &#34;2.1 beta (build 20091113-0841)&#34;; // promoted</TD></TR><TR><TD CLASS="l">101</TD><TD>//        return &#34;2.1 beta (build 20091028-0900)&#34;; // promoted</TD></TR><TR><TD CLASS="l">102</TD><TD>//        return &#34;2.1 beta (build 20091014-1030)&#34;; // promoted</TD></TR><TR><TD CLASS="l">103</TD><TD>//        return &#34;2.x beta (build 20091007-2026)&#34;; // promote date, but forgot to update</TD></TR><TR><TD CLASS="l">104</TD><TD>//        return &#34;2.x beta (build 20091005-1015)&#34;; // promoted</TD></TR><TR><TD CLASS="l">105</TD><TD>//        return &#34;2.x beta (build 20091002-1300)&#34;; // promoted</TD></TR><TR><TD CLASS="l">106</TD><TD>//        return &#34;2.x beta (build 20090930-1524)&#34;; // promoted</TD></TR><TR><TD CLASS="l">107</TD><TD>//        return &#34;2.x beta (build 20090929-1249)&#34;; // not promoted</TD></TR><TR><TD CLASS="l"><A NAME="19">108</A></TD><TD>//        return &#34;2.x beta (build 20090924-1645)&#34;;</TD></TR><TR><TD CLASS="l">109</TD><TD>    }</TD></TR><TR><TD CLASS="l">110</TD><TD> </TD></TR><TR><TD CLASS="l">111</TD><TD>    public static boolean isVerbose () {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="c">112</A></TD><TD>        return inst().optVerbose;</TD></TR><TR><TD CLASS="l">113</TD><TD>    }</TD></TR><TR><TD CLASS="l">114</TD><TD> </TD></TR><TR><TD CLASS="l">115</TD><TD>    public static boolean isDebugOn () {</TD></TR><TR CLASS="p"><TD TITLE="56% line coverage (5 out of 9 instructions)" CLASS="l">116</TD><TD TITLE="56% line coverage (5 out of 9 instructions)">        return inst().optDebug &amp;&amp; isVerbose();</TD></TR><TR><TD CLASS="l">117</TD><TD>    }</TD></TR><TR><TD CLASS="l">118</TD><TD> </TD></TR><TR><TD CLASS="l">119</TD><TD>    /**</TD></TR><TR><TD CLASS="l">120</TD><TD>     * Returns whether the state machine should trace its execution.</TD></TR><TR><TD CLASS="l"><A NAME="b">121</A></TD><TD>     * </TD></TR><TR><TD CLASS="l">122</TD><TD>     * @return &lt;code&gt;true&lt;/code&gt; if execution trace should be ON, &lt;code&gt;false&lt;/code&gt; otherwise.  </TD></TR><TR><TD CLASS="l">123</TD><TD>     */</TD></TR><TR><TD CLASS="l">124</TD><TD>    public static boolean isExecutionTraceOn () {</TD></TR><TR CLASS="c"><TD CLASS="l">125</TD><TD>        if (inst().optNoTrace == null) {</TD></TR><TR><TD CLASS="l">126</TD><TD>            // read system property, default to &#34;false&#34; as trace is on by default</TD></TR><TR CLASS="z"><TD CLASS="l">127</TD><TD>            inst().optNoTrace = Util.getSysBoolWithDefault(PROP_NO_TRACE, false);</TD></TR><TR><TD CLASS="l">128</TD><TD>        }</TD></TR><TR CLASS="p"><TD TITLE="75% line coverage (6 out of 8 instructions)" CLASS="l">129</TD><TD TITLE="75% line coverage (6 out of 8 instructions)">        return !inst().optNoTrace;</TD></TR><TR><TD CLASS="l">130</TD><TD>    }</TD></TR><TR><TD CLASS="l">131</TD><TD> </TD></TR><TR><TD CLASS="l">132</TD><TD>    /**</TD></TR><TR><TD CLASS="l">133</TD><TD>     * Returns whether to ignore duplicates in XMI IDs across multiple state machines.</TD></TR><TR><TD CLASS="l">134</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="2">135</A></TD><TD>     * @return &lt;code&gt;true&lt;/code&gt; if duplicate XMI IDs across multiple state</TD></TR><TR><TD CLASS="l">136</TD><TD>     * machines should be ignored, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">137</TD><TD>     */</TD></TR><TR><TD CLASS="l">138</TD><TD>    public static boolean ignoreDuplicateXmiIds () {</TD></TR><TR CLASS="z"><TD CLASS="l">139</TD><TD>        if (inst().optIgnoreDupXmiIDs == null) {</TD></TR><TR><TD CLASS="l">140</TD><TD>            // read system property, default to NOT ignoring duplicate XMI IDs</TD></TR><TR CLASS="z"><TD CLASS="l">141</TD><TD>            inst().optIgnoreDupXmiIDs = Util.getSysBoolWithDefault(PROP_IGNORE_DUP_IDS, false);</TD></TR><TR><TD CLASS="l">142</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">143</TD><TD>        return inst().optIgnoreDupXmiIDs;</TD></TR><TR><TD CLASS="l">144</TD><TD>    }</TD></TR><TR><TD CLASS="l">145</TD><TD> </TD></TR><TR><TD CLASS="l">146</TD><TD>    /**</TD></TR><TR><TD CLASS="l">147</TD><TD>     * Returns whether to qualify the state transition signal names.</TD></TR><TR><TD CLASS="l"><A NAME="5">148</A></TD><TD>     *  </TD></TR><TR><TD CLASS="l">149</TD><TD>     * @return &lt;code&gt;true&lt;/code&gt; if signal names should be fully-qualified, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">150</TD><TD>     */</TD></TR><TR><TD CLASS="l">151</TD><TD>    public static boolean qualifySignals () {</TD></TR><TR CLASS="z"><TD CLASS="l">152</TD><TD>        if (inst().optQualifySignals == null) {</TD></TR><TR><TD CLASS="l">153</TD><TD>            // read system property, default to NOT qualifying signals</TD></TR><TR CLASS="z"><TD CLASS="l">154</TD><TD>            inst().optQualifySignals = Util.getSysBoolWithDefault(PROP_QUALIFY_SIGNALS, false);</TD></TR><TR><TD CLASS="l">155</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">156</TD><TD>        return inst().optQualifySignals;</TD></TR><TR><TD CLASS="l">157</TD><TD>    }</TD></TR><TR><TD CLASS="l">158</TD><TD> </TD></TR><TR><TD CLASS="l">159</TD><TD>    /**</TD></TR><TR><TD CLASS="l">160</TD><TD>     * Returns whether system property &#34;DEFINE_MAIN&#34; has been set, indicating</TD></TR><TR><TD CLASS="l">161</TD><TD>     * if main method should be generated.</TD></TR><TR><TD CLASS="l"><A NAME="11">162</A></TD><TD>     * </TD></TR><TR><TD CLASS="l">163</TD><TD>     * @return &lt;code&gt;true&lt;/code&gt; if main method should be generated, &lt;code&gt;false&lt;/code&gt; otherwise.  </TD></TR><TR><TD CLASS="l">164</TD><TD>     */</TD></TR><TR><TD CLASS="l">165</TD><TD>    public static boolean ifDefineMain () {</TD></TR><TR CLASS="p"><TD TITLE="71% line coverage (5 out of 7 instructions)" CLASS="l">166</TD><TD TITLE="71% line coverage (5 out of 7 instructions)">        return System.getProperty(FLAG_DEFINE_MAIN) != null;</TD></TR><TR><TD CLASS="l">167</TD><TD>    }</TD></TR><TR><TD CLASS="l">168</TD><TD> </TD></TR><TR><TD CLASS="l">169</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="12">170</A></TD><TD>     * Returns target kind for which the autocoder is currently generating code.</TD></TR><TR><TD CLASS="l">171</TD><TD>     * @return Kind of generator currently in process</TD></TR><TR><TD CLASS="l">172</TD><TD>     */</TD></TR><TR><TD CLASS="l">173</TD><TD>    public static Kind autocodingTarget () {</TD></TR><TR CLASS="c"><TD CLASS="l">174</TD><TD>        if (Util.getSysBoolWithDefault(PROP_TARGET_C, false)) {</TD></TR><TR CLASS="z"><TD CLASS="l">175</TD><TD>            return Kind.CNonTemplate;  // backward compatibility for old writers</TD></TR><TR><TD CLASS="l">176</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">177</TD><TD>            return inst().curGenTarget;</TD></TR><TR><TD CLASS="l">178</TD><TD>        }</TD></TR><TR><TD CLASS="l">179</TD><TD>    }</TD></TR><TR><TD CLASS="l">180</TD><TD> </TD></TR><TR><TD CLASS="l">181</TD><TD>    /**</TD></TR><TR><TD CLASS="l">182</TD><TD>     * Checks and returns whether the supplied State Machine name may have been</TD></TR><TR><TD CLASS="l">183</TD><TD>     * one of the specifically requested State Machines.</TD></TR><TR><TD CLASS="l">184</TD><TD>     * Supplied State Machine name should be a short name, while requests</TD></TR><TR><TD CLASS="l">185</TD><TD>     * may specify the minimal name that uniquely identifies a State Machine.</TD></TR><TR><TD CLASS="l">186</TD><TD>     * For example, if the requested set contains &lt;blockquote&gt;</TD></TR><TR><TD CLASS="l">187</TD><TD>     * { &#34;SM&#34;, &#34;p1::SM&#34;, &#34;p1::ASM&#34;, &#34;p1::p2::SM&#34; }</TD></TR><TR><TD CLASS="l">188</TD><TD>     * &lt;/blockquote&gt;</TD></TR><TR><TD CLASS="l">189</TD><TD>     * the following would return &lt;code&gt;true&lt;/code&gt;: &lt;blockquote&gt;</TD></TR><TR><TD CLASS="l">190</TD><TD>     * specificSMRequested(&#34;SM&#34;)&lt;br&gt;</TD></TR><TR><TD CLASS="l">191</TD><TD>     * specificSMRequested(&#34;ASM&#34;)</TD></TR><TR><TD CLASS="l">192</TD><TD>     * &lt;/blockquote&gt;</TD></TR><TR><TD CLASS="l">193</TD><TD>     * while the following would return &lt;code&gt;false&lt;/code&gt;: &lt;blockquote&gt;</TD></TR><TR><TD CLASS="l">194</TD><TD>     * specificSMRequested(&#34;M&#34;)</TD></TR><TR><TD CLASS="l">195</TD><TD>     * &lt;/blockquote&gt;</TD></TR><TR><TD CLASS="l">196</TD><TD>     * If the requested set is empty, any &lt;code&gt;name&lt;/code&gt; would return &lt;code&gt;false&lt;/code&gt;. </TD></TR><TR><TD CLASS="l">197</TD><TD>     * If the requested set is nonempty, a &lt;code&gt;null&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;. </TD></TR><TR><TD CLASS="l">198</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="a">199</A></TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if the supplied State Machine name may be one</TD></TR><TR><TD CLASS="l">200</TD><TD>     *      of the specifically requested State Machines; &lt;code&gt;false&lt;/code&gt; otherwise</TD></TR><TR><TD CLASS="l">201</TD><TD>     */</TD></TR><TR><TD CLASS="l">202</TD><TD>    public static boolean specificSMRequested (String name) {</TD></TR><TR CLASS="c"><TD CLASS="l">203</TD><TD>        boolean rv = false;</TD></TR><TR CLASS="c"><TD CLASS="l">204</TD><TD>        if (inst().smToGen.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">205</TD><TD>            if (name == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">206</TD><TD>                rv = true;</TD></TR><TR><TD CLASS="l">207</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">208</TD><TD>                for (String reqName : inst().smToGen) {</TD></TR><TR CLASS="z"><TD CLASS="l">209</TD><TD>                    int chkIdx = reqName.lastIndexOf(TargetLanguageMapper.UML_SEPARATOR);</TD></TR><TR CLASS="z"><TD CLASS="l">210</TD><TD>                    if (chkIdx == -1) {  // no separator, compare whole string</TD></TR><TR CLASS="z"><TD CLASS="l">211</TD><TD>                        chkIdx = 0;</TD></TR><TR><TD CLASS="l">212</TD><TD>                    } else {</TD></TR><TR CLASS="z"><TD CLASS="l">213</TD><TD>                        chkIdx += TargetLanguageMapper.UML_SEPARATOR.length();</TD></TR><TR><TD CLASS="l">214</TD><TD>                    }</TD></TR><TR CLASS="z"><TD CLASS="l">215</TD><TD>                    if (reqName.substring(chkIdx).equals(name)) {  // found</TD></TR><TR CLASS="z"><TD CLASS="l">216</TD><TD>                        rv = true;</TD></TR><TR CLASS="z"><TD CLASS="l">217</TD><TD>                        break;  // done</TD></TR><TR><TD CLASS="l">218</TD><TD>                    }</TD></TR><TR><TD CLASS="l">219</TD><TD>                }</TD></TR><TR><TD CLASS="l">220</TD><TD>            }</TD></TR><TR><TD CLASS="l">221</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>        return rv;</TD></TR><TR><TD CLASS="l">223</TD><TD>    }</TD></TR><TR><TD CLASS="l">224</TD><TD> </TD></TR><TR><TD CLASS="l">225</TD><TD>    /**</TD></TR><TR><TD CLASS="l">226</TD><TD>     * Returns whether to filter only relevant events, which is based on whether</TD></TR><TR><TD CLASS="l">227</TD><TD>     * request has been made to generate specific State Machines, and whether</TD></TR><TR><TD CLASS="l">228</TD><TD>     * we're autocoding signals.</TD></TR><TR><TD CLASS="l"><A NAME="f">229</A></TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if only Transition events should be filtered,</TD></TR><TR><TD CLASS="l">230</TD><TD>     *  &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">231</TD><TD>     */</TD></TR><TR><TD CLASS="l">232</TD><TD>    public static boolean filterTransitionEvents () {</TD></TR><TR CLASS="p"><TD TITLE="60% line coverage (6 out of 10 instructions)" CLASS="l">233</TD><TD TITLE="60% line coverage (6 out of 10 instructions)">        return inst().smToGen.size() &gt; 0 &amp;&amp; !signalGenRequested();</TD></TR><TR><TD CLASS="l">234</TD><TD>    }</TD></TR><TR><TD CLASS="l">235</TD><TD> </TD></TR><TR><TD CLASS="l">236</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="18">237</A></TD><TD>     * Returns whether implementation function calls should be &#34;live.&#34;</TD></TR><TR><TD CLASS="l">238</TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if impl-calls should be uncommented, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">239</TD><TD>     */</TD></TR><TR><TD CLASS="l">240</TD><TD>    public static boolean isImplCallLive () {</TD></TR><TR CLASS="c"><TD CLASS="l">241</TD><TD>        return inst().optImplCall;</TD></TR><TR><TD CLASS="l">242</TD><TD>    }</TD></TR><TR><TD CLASS="l">243</TD><TD> </TD></TR><TR><TD CLASS="l">244</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="1">245</A></TD><TD>     * Returns whether duplicate StateMachine names are allowed.</TD></TR><TR><TD CLASS="l">246</TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if duplicate SM names allowed, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">247</TD><TD>     */</TD></TR><TR><TD CLASS="l">248</TD><TD>    public static boolean allowDupSMName () {</TD></TR><TR CLASS="z"><TD CLASS="l">249</TD><TD>        return inst().optDupSMName;</TD></TR><TR><TD CLASS="l">250</TD><TD>    }</TD></TR><TR><TD CLASS="l">251</TD><TD> </TD></TR><TR><TD CLASS="l">252</TD><TD>    /**</TD></TR><TR><TD CLASS="l">253</TD><TD>     * Returns whether signals are being generated as a separate step; if so,</TD></TR><TR><TD CLASS="l">254</TD><TD>     * other generators can skip that step to avoid duplicate processing.</TD></TR><TR><TD CLASS="l"><A NAME="1c">255</A></TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if signal generation has been requested separately,</TD></TR><TR><TD CLASS="l">256</TD><TD>     *   &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">257</TD><TD>     */</TD></TR><TR><TD CLASS="l">258</TD><TD>    public static boolean signalGenRequested () {</TD></TR><TR CLASS="c"><TD CLASS="l">259</TD><TD>        return inst().propGenTargets.contains(Kind.Signals);</TD></TR><TR><TD CLASS="l">260</TD><TD>    }</TD></TR><TR><TD CLASS="l">261</TD><TD> </TD></TR><TR><TD CLASS="l">262</TD><TD> </TD></TR><TR><TD CLASS="l">263</TD><TD>    /* command-line options</TD></TR><TR><TD CLASS="l">264</TD><TD>     * - default null to allow old way of setting via system properties </TD></TR><TR><TD CLASS="l">265</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">266</TD><TD>    private Boolean optNoTrace = null;</TD></TR><TR CLASS="c"><TD CLASS="l">267</TD><TD>    private Boolean optQualifySignals = null;</TD></TR><TR CLASS="c"><TD CLASS="l">268</TD><TD>    private Boolean optIgnoreDupXmiIDs = null;</TD></TR><TR><TD CLASS="l">269</TD><TD>    // verbosity of Autocoder diagnostic output</TD></TR><TR CLASS="c"><TD CLASS="l">270</TD><TD>    private boolean optVerbose = false;</TD></TR><TR><TD CLASS="l">271</TD><TD>    // debug flag for Autocoder debug output</TD></TR><TR CLASS="c"><TD CLASS="l">272</TD><TD>    private boolean optDebug = false;</TD></TR><TR><TD CLASS="l">273</TD><TD>    // list of generator kinds this autocoder is to target </TD></TR><TR CLASS="c"><TD CLASS="l">274</TD><TD>    private List&lt;Kind&gt; propGenTargets = null;</TD></TR><TR><TD CLASS="l">275</TD><TD>    // set of specific state machines to output</TD></TR><TR CLASS="c"><TD CLASS="l">276</TD><TD>    private Set&lt;String&gt; smToGen = null;</TD></TR><TR><TD CLASS="l">277</TD><TD>    // flag indicating whether to make impl-calls &#34;live&#34; (as in, uncommented)</TD></TR><TR CLASS="c"><TD CLASS="l">278</TD><TD>    private boolean optImplCall = false;</TD></TR><TR><TD CLASS="l">279</TD><TD>    // flag indicating whether to allow duplicate StateMachine names</TD></TR><TR CLASS="c"><TD CLASS="l">280</TD><TD>    private boolean optDupSMName = false;</TD></TR><TR><TD CLASS="l">281</TD><TD> </TD></TR><TR><TD CLASS="l">282</TD><TD>    // current generator target, used by old writers to see if they're autocoding C</TD></TR><TR CLASS="c"><TD CLASS="l">283</TD><TD>    private Kind curGenTarget = null;</TD></TR><TR><TD CLASS="l">284</TD><TD>    // map of generator Kind to class</TD></TR><TR CLASS="c"><TD CLASS="l">285</TD><TD>    private Map&lt;Kind,Class&lt;? extends IGenerator&gt;&gt; generatorMap = null;</TD></TR><TR><TD CLASS="l">286</TD><TD>    // list of input files to process</TD></TR><TR CLASS="c"><TD CLASS="l">287</TD><TD>    private List&lt;String&gt; fileList = null;</TD></TR><TR><TD CLASS="l">288</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">289</TD><TD>    private boolean doAbort = false;</TD></TR><TR CLASS="c"><TD CLASS="l">290</TD><TD>    private Timer timer = null;</TD></TR><TR><TD CLASS="l">291</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="15">292</A></TD><TD> </TD></TR><TR><TD CLASS="l">293</TD><TD>    /**</TD></TR><TR><TD CLASS="l">294</TD><TD>     * Default private constructor.</TD></TR><TR><TD CLASS="l">295</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">296</TD><TD>    private Autocoder () {</TD></TR><TR CLASS="c"><TD CLASS="l">297</TD><TD>        propGenTargets = new ArrayList&lt;Kind&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">298</TD><TD>        generatorMap = new HashMap&lt;Kind, Class&lt;? extends IGenerator&gt;&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">299</TD><TD>        fileList = new ArrayList&lt;String&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">300</TD><TD>        smToGen = new LinkedHashSet&lt;String&gt;();  // preserve insertion order</TD></TR><TR CLASS="c"><TD CLASS="l">301</TD><TD>        timer = new Timer();  // init timer to time whole process</TD></TR><TR CLASS="c"><TD CLASS="l">302</TD><TD>    }</TD></TR><TR><TD CLASS="l">303</TD><TD> </TD></TR><TR><TD CLASS="l">304</TD><TD>    /**</TD></TR><TR><TD CLASS="l">305</TD><TD>     * Initializes the Autocoder application, including processing the</TD></TR><TR><TD CLASS="l">306</TD><TD>     * command-line arguments, finding the available generators in classpaths,</TD></TR><TR><TD CLASS="l">307</TD><TD>     * and determining the output targets designated by command-line options.</TD></TR><TR><TD CLASS="l">308</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="10">309</A></TD><TD>     * @param args  input command-line arguments </TD></TR><TR><TD CLASS="l">310</TD><TD>     */</TD></TR><TR><TD CLASS="l">311</TD><TD>    public void init (String [] args) {</TD></TR><TR><TD CLASS="l">312</TD><TD>        // initialize the switch options with defaults</TD></TR><TR CLASS="c"><TD CLASS="l">313</TD><TD>        if (optIgnoreDupXmiIDs == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>            optIgnoreDupXmiIDs = false;</TD></TR><TR><TD CLASS="l">315</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">316</TD><TD>        if (optNoTrace == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">317</TD><TD>            optNoTrace = false;</TD></TR><TR><TD CLASS="l">318</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">319</TD><TD>        if (optQualifySignals == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">320</TD><TD>            optQualifySignals = false;</TD></TR><TR><TD CLASS="l">321</TD><TD>        }</TD></TR><TR><TD CLASS="l">322</TD><TD> </TD></TR><TR><TD CLASS="l">323</TD><TD>        // first, find all generators available in &#34;scope&#34; (i.e., classpaths)</TD></TR><TR><TD CLASS="l">324</TD><TD>        //- this way, usage help correctly reflects unavailable generators</TD></TR><TR CLASS="c"><TD CLASS="l">325</TD><TD>        findGenerators();</TD></TR><TR><TD CLASS="l">326</TD><TD> </TD></TR><TR><TD CLASS="l">327</TD><TD>        // process command-line arguments and get input files ready</TD></TR><TR CLASS="c"><TD CLASS="l">328</TD><TD>        processCommandArguments(args);</TD></TR><TR><TD CLASS="l">329</TD><TD> </TD></TR><TR><TD CLASS="l">330</TD><TD>        // print option status to stdout</TD></TR><TR CLASS="c"><TD CLASS="l">331</TD><TD>        System.out.println(&#34;Autocoder &#34; + version());</TD></TR><TR CLASS="c"><TD CLASS="l">332</TD><TD>        System.out.println(&#34;/ CWD &#34; + System.getProperty(&#34;user.dir&#34;));</TD></TR><TR CLASS="p"><TD TITLE="90% line coverage (27 out of 30 instructions)" CLASS="l">333</TD><TD TITLE="90% line coverage (27 out of 30 instructions)">        if (optVerbose)         System.out.println(&#34;|*opt: Enabling verbose output&#34;);</TD></TR><TR CLASS="p"><TD TITLE="50% line coverage (3 out of 6 instructions)" CLASS="l">334</TD><TD TITLE="50% line coverage (3 out of 6 instructions)">        if (optDebug)           System.out.println(&#34;|*opt: Enabling debug output&#34;);</TD></TR><TR CLASS="p"><TD TITLE="57% line coverage (4 out of 7 instructions)" CLASS="l">335</TD><TD TITLE="57% line coverage (4 out of 7 instructions)">        if (optIgnoreDupXmiIDs) System.out.println(&#34;|*opt: Ignoring duplicate XMI IDs&#34;);</TD></TR><TR CLASS="p"><TD TITLE="57% line coverage (4 out of 7 instructions)" CLASS="l">336</TD><TD TITLE="57% line coverage (4 out of 7 instructions)">        if (optNoTrace)         System.out.println(&#34;|*opt: Turning off execution tracing&#34;);</TD></TR><TR CLASS="p"><TD TITLE="57% line coverage (4 out of 7 instructions)" CLASS="l">337</TD><TD TITLE="57% line coverage (4 out of 7 instructions)">        if (optQualifySignals)  System.out.println(&#34;|*opt: Qualifying signals&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>        if (optImplCall)        System.out.println(&#34;|*opt: Turning on implementation function calls&#34;);</TD></TR><TR CLASS="p"><TD TITLE="50% line coverage (3 out of 6 instructions)" CLASS="l">339</TD><TD TITLE="50% line coverage (3 out of 6 instructions)">        if (optDupSMName)       System.out.println(&#34;|*opt: Allowing duplicate StateMachine names&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">340</TD><TD>        if (smToGen.size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">341</TD><TD>            System.out.println(&#34;|*opt: Generating only specific State Machine&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">342</TD><TD>                    + (smToGen.size() &gt; 1 ? &#34;s&#34; : &#34;&#34;)</TD></TR><TR CLASS="z"><TD CLASS="l">343</TD><TD>                    + &#34; &#34; + smToGen.toString());</TD></TR><TR><TD CLASS="l">344</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>        System.out.println(&#34;\\ Found generator kind(s) &#34; + Arrays.toString(generatorMap.keySet().toArray()));</TD></TR><TR><TD CLASS="l">346</TD><TD> </TD></TR><TR><TD CLASS="l">347</TD><TD>        // if no output target is found, print usage and exit</TD></TR><TR CLASS="c"><TD CLASS="l">348</TD><TD>        if (propGenTargets.isEmpty()) {</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>            System.err.println(&#34;**No generator target specified, nothing to do!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">350</TD><TD>            printUsageAndExit();</TD></TR><TR><TD CLASS="l">351</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>    }</TD></TR><TR><TD CLASS="l">353</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="13">354</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">355</TD><TD>     * No real disposing necessary, just outputs any final messages before finishing.</TD></TR><TR><TD CLASS="l">356</TD><TD>     */</TD></TR><TR><TD CLASS="l">357</TD><TD>    public void dispose () {</TD></TR><TR CLASS="c"><TD CLASS="l">358</TD><TD>        long dur = timer.markTime();</TD></TR><TR CLASS="c"><TD CLASS="l">359</TD><TD>        StringBuilder sb = new StringBuilder(&#34;Autocoding &#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">360</TD><TD>        if (doAbort) {</TD></TR><TR CLASS="z"><TD CLASS="l">361</TD><TD>            sb.append(&#34;Aborted&#34;);</TD></TR><TR><TD CLASS="l">362</TD><TD>        } else {</TD></TR><TR CLASS="c"><TD CLASS="l">363</TD><TD>            sb.append(&#34;Finished&#34;);</TD></TR><TR><TD CLASS="l">364</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">365</TD><TD>        sb.append(&#34; (&#34; + dur + &#34;ms).&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">366</TD><TD>        System.out.println(sb.toString());</TD></TR><TR CLASS="c"><TD CLASS="l">367</TD><TD>        System.out.println();</TD></TR><TR><TD CLASS="l">368</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">369</TD><TD>        if (doAbort) {  // return error to system</TD></TR><TR CLASS="z"><TD CLASS="l">370</TD><TD>            System.exit(-1);</TD></TR><TR><TD CLASS="l">371</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">372</TD><TD>    }</TD></TR><TR><TD CLASS="l">373</TD><TD> </TD></TR><TR><TD CLASS="l">374</TD><TD> </TD></TR><TR><TD CLASS="l">375</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="8">376</A></TD><TD>     * Sets the flag that controls whether to disable GUI execution trace.</TD></TR><TR><TD CLASS="l">377</TD><TD>     * @param b  new boolean state to set to</TD></TR><TR><TD CLASS="l">378</TD><TD>     */</TD></TR><TR><TD CLASS="l">379</TD><TD>    public void setNoTrace (boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l">380</TD><TD>        optNoTrace = b;</TD></TR><TR CLASS="z"><TD CLASS="l">381</TD><TD>    }</TD></TR><TR><TD CLASS="l">382</TD><TD> </TD></TR><TR><TD CLASS="l">383</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="9">384</A></TD><TD>     * Sets the flag that controls output verbosity of Autocoder.</TD></TR><TR><TD CLASS="l">385</TD><TD>     * @param b  new boolean state to set to</TD></TR><TR><TD CLASS="l">386</TD><TD>     */</TD></TR><TR><TD CLASS="l">387</TD><TD>    public void setVerbose (boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>        optVerbose = b;</TD></TR><TR CLASS="z"><TD CLASS="l">389</TD><TD>    }</TD></TR><TR><TD CLASS="l">390</TD><TD> </TD></TR><TR><TD CLASS="l">391</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="6">392</A></TD><TD>     * Sets the flag that controls debug output of Autocoder.</TD></TR><TR><TD CLASS="l">393</TD><TD>     * @param b  new boolean state to set to</TD></TR><TR><TD CLASS="l">394</TD><TD>     */</TD></TR><TR><TD CLASS="l">395</TD><TD>    public void setDebugOn (boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l">396</TD><TD>        optDebug = b;</TD></TR><TR CLASS="z"><TD CLASS="l">397</TD><TD>    }</TD></TR><TR><TD CLASS="l">398</TD><TD> </TD></TR><TR><TD CLASS="l">399</TD><TD>    /**</TD></TR><TR><TD CLASS="l">400</TD><TD>     * Sets the flag that controls whether ImplClass function calls are</TD></TR><TR><TD CLASS="l"><A NAME="1b">401</A></TD><TD>     * written out uncommented, &lt;code&gt;true&lt;/code&gt; to uncomment.</TD></TR><TR><TD CLASS="l">402</TD><TD>     * @param b  new boolean state to set to</TD></TR><TR><TD CLASS="l">403</TD><TD>     */</TD></TR><TR><TD CLASS="l">404</TD><TD>    public void setImplCall (boolean b) {</TD></TR><TR CLASS="c"><TD CLASS="l">405</TD><TD>        optImplCall = b;</TD></TR><TR CLASS="c"><TD CLASS="l">406</TD><TD>    }</TD></TR><TR><TD CLASS="l">407</TD><TD> </TD></TR><TR><TD CLASS="l">408</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="7">409</A></TD><TD>     * Sets the flag that allows duplicate StateMachine names.</TD></TR><TR><TD CLASS="l">410</TD><TD>     * @param b  new boolean state to set to</TD></TR><TR><TD CLASS="l">411</TD><TD>     */</TD></TR><TR><TD CLASS="l">412</TD><TD>    public void setDupSMName (boolean b) {</TD></TR><TR CLASS="z"><TD CLASS="l">413</TD><TD>        optDupSMName = b;</TD></TR><TR CLASS="z"><TD CLASS="l">414</TD><TD>    }</TD></TR><TR><TD CLASS="l">415</TD><TD> </TD></TR><TR><TD CLASS="l">416</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="d">417</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">418</TD><TD>     * Invokes designated generators on all inputs.</TD></TR><TR><TD CLASS="l">419</TD><TD>     */</TD></TR><TR><TD CLASS="l">420</TD><TD>    public void generate () {</TD></TR><TR CLASS="c"><TD CLASS="l">421</TD><TD>        IReader reader = null;</TD></TR><TR CLASS="c"><TD CLASS="l">422</TD><TD>        String[] inputs = fileList.toArray(new String[0]);</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">424</TD><TD>        for (Kind target : propGenTargets) {</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>            System.out.println(&#34;Autocoding to target &#34; + target.label());</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>            curGenTarget = target;</TD></TR><TR><TD CLASS="l">427</TD><TD> </TD></TR><TR><TD CLASS="l">428</TD><TD>            // Instantiate generator class</TD></TR><TR><TD CLASS="l">429</TD><TD>            try {</TD></TR><TR CLASS="c"><TD CLASS="l">430</TD><TD>                Class&lt;? extends IGenerator&gt; genClass = generatorMap.get(target);</TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>                if (genClass == null) {  // can't continue</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>                    System.err.println(&#34;**Sorry! No generator found for target &#34; + target.label());</TD></TR><TR CLASS="z"><TD CLASS="l">433</TD><TD>                    System.err.println(&#34;** Make sure that the generator exists in the Jar or classpath.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">434</TD><TD>                    continue;</TD></TR><TR><TD CLASS="l">435</TD><TD>                }</TD></TR><TR CLASS="c"><TD CLASS="l">436</TD><TD>                IGenerator generator = genClass.newInstance();</TD></TR><TR><TD CLASS="l">437</TD><TD>                // Invoke generator using existing reader, if any, on the entire list of input sources</TD></TR><TR CLASS="c"><TD CLASS="l">438</TD><TD>                generator.generate(reader, inputs);</TD></TR><TR CLASS="c"><TD CLASS="l">439</TD><TD>                if (reader == null) {</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>                    reader = generator.reader();  // save the reader</TD></TR><TR><TD CLASS="l">441</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">442</TD><TD>            } catch (InstantiationException e) {  // ignore</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>            } catch (IllegalAccessException e) {  // ignore</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>            } catch (FatalModelException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>                doAbort = true;</TD></TR><TR><TD CLASS="l">446</TD><TD>                </TD></TR><TR><TD CLASS="l">447</TD><TD>                // sending output to stdout to ensure context</TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>                System.out.println(e.getLocalizedMessage());</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>                System.out.println(&#34;**ABORT target &#34; + target.label()</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>                        + &#34;! Fatal model error(s) prevented Autocoder from generating proper code!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">451</TD><TD>                break;</TD></TR><TR><TD CLASS="l">452</TD><TD>            }</TD></TR><TR><TD CLASS="l">453</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">454</TD><TD>    }</TD></TR><TR><TD CLASS="l">455</TD><TD> </TD></TR><TR><TD CLASS="l">456</TD><TD>    /**</TD></TR><TR><TD CLASS="l">457</TD><TD>     * Finds all generator classes within this Autocoder class hierarchy that</TD></TR><TR><TD CLASS="l">458</TD><TD>     * implement the {@link IWriter} interface and are annotated with {@link GeneratorKind},</TD></TR><TR><TD CLASS="l"><A NAME="16">459</A></TD><TD>     * and populate the generator map of {@link Kind} to {@link Class}.</TD></TR><TR><TD CLASS="l">460</TD><TD>     */</TD></TR><TR><TD CLASS="l">461</TD><TD>    private void findGenerators () {</TD></TR><TR CLASS="c"><TD CLASS="l">462</TD><TD>        for (Class&lt;? extends IGenerator&gt; c</TD></TR><TR CLASS="c"><TD CLASS="l">463</TD><TD>                : Util.findSubclassesUnder(IGenerator.class, &#34;.+Gen.+&#34;)) {</TD></TR><TR><TD CLASS="l">464</TD><TD>            // get class and read its annotations for Generator Kind</TD></TR><TR CLASS="c"><TD CLASS="l">465</TD><TD>            GeneratorKind kindAnnote = c.getAnnotation(GeneratorKind.class);</TD></TR><TR CLASS="c"><TD CLASS="l">466</TD><TD>            if (kindAnnote != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">467</TD><TD>                generatorMap.put(kindAnnote.value(), c);</TD></TR><TR><TD CLASS="l">468</TD><TD>            }</TD></TR><TR><TD CLASS="l">469</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="e">470</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">471</TD><TD> </TD></TR><TR><TD CLASS="l">472</TD><TD>    private void processCommandArguments (String [] args) {</TD></TR><TR><TD CLASS="l">473</TD><TD>        // store argument list</TD></TR><TR CLASS="c"><TD CLASS="l">474</TD><TD>        List&lt;String&gt; argList = new LinkedList&lt;String&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">475</TD><TD>        argList.addAll(Arrays.asList(args));</TD></TR><TR><TD CLASS="l">476</TD><TD> </TD></TR><TR><TD CLASS="l">477</TD><TD>        /* process the options, using array index</TD></TR><TR><TD CLASS="l">478</TD><TD>         * - index is always incremented at the beginning of the next loop</TD></TR><TR><TD CLASS="l">479</TD><TD>         * - after an arg is removed, we must decrement index to account for it</TD></TR><TR><TD CLASS="l">480</TD><TD>         */</TD></TR><TR CLASS="c"><TD CLASS="l">481</TD><TD>        for (int i=0; i &lt; argList.size(); ++i) {</TD></TR><TR CLASS="c"><TD CLASS="l">482</TD><TD>            String arg = argList.remove(i--);  // decrement idx _after_ removal</TD></TR><TR CLASS="c"><TD CLASS="l">483</TD><TD>            if (arg.equals(OPT_USAGE)) {</TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>                printUsageAndExit();</TD></TR><TR><TD CLASS="l">485</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">486</TD><TD>            } else if (arg.equals(OPT_IGNORE_DUP_IDS)) {</TD></TR><TR CLASS="z"><TD CLASS="l">487</TD><TD>                optIgnoreDupXmiIDs = true;</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">489</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">490</TD><TD>            } else if (arg.equals(OPT_NO_TRACE)) {</TD></TR><TR CLASS="z"><TD CLASS="l">491</TD><TD>                setNoTrace(true);</TD></TR><TR CLASS="z"><TD CLASS="l">492</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">493</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">494</TD><TD>            } else if (arg.equals(OPT_QUALIFY_SIGNALS)) {</TD></TR><TR CLASS="z"><TD CLASS="l">495</TD><TD>                optQualifySignals = true;</TD></TR><TR CLASS="z"><TD CLASS="l">496</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">497</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">498</TD><TD>            } else if (arg.equals(OPT_VERBOSE)) {</TD></TR><TR CLASS="z"><TD CLASS="l">499</TD><TD>                setVerbose(true);</TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">501</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">502</TD><TD>            } else if (arg.equals(OPT_DEBUG)) {</TD></TR><TR CLASS="z"><TD CLASS="l">503</TD><TD>                setDebugOn(true);</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">505</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">506</TD><TD>            } else if (arg.equals(OPT_VERSION)) {</TD></TR><TR CLASS="z"><TD CLASS="l">507</TD><TD>                printVersionAndExit();</TD></TR><TR><TD CLASS="l">508</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">509</TD><TD>            } else if (arg.equals(OPT_STATE_MACHINE)) {  // fetch option argument</TD></TR><TR CLASS="z"><TD CLASS="l">510</TD><TD>                String smName = argList.remove(i+1);</TD></TR><TR CLASS="z"><TD CLASS="l">511</TD><TD>                if (smName.startsWith(&#34;-&#34;)) {  // error?!</TD></TR><TR CLASS="z"><TD CLASS="l">512</TD><TD>                    System.err.println(&#34;Error! &#34; + arg + &#34; should be followed by a State Machine name, not another option!&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">513</TD><TD>                    printUsageAndExit();</TD></TR><TR><TD CLASS="l">514</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l">515</TD><TD>                smToGen.add(smName);</TD></TR><TR CLASS="z"><TD CLASS="l">516</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">517</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">518</TD><TD>            } else if (arg.equals(OPT_IMPL_CALLS)) {</TD></TR><TR CLASS="c"><TD CLASS="l">519</TD><TD>                setImplCall(true);</TD></TR><TR CLASS="c"><TD CLASS="l">520</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">521</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">522</TD><TD>            } else if (arg.equals(OPT_DUP_SM)) {</TD></TR><TR CLASS="z"><TD CLASS="l">523</TD><TD>                setDupSMName(true);</TD></TR><TR CLASS="z"><TD CLASS="l">524</TD><TD>                continue;</TD></TR><TR><TD CLASS="l">525</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">526</TD><TD>            } else if (opt2GenKindMap.containsKey(arg)) {  // generator option</TD></TR><TR CLASS="c"><TD CLASS="l">527</TD><TD>                propGenTargets.add(opt2GenKindMap.get(arg));</TD></TR><TR><TD CLASS="l">528</TD><TD> </TD></TR><TR><TD CLASS="l">529</TD><TD>            } else {  // warn about unknown options, but skip input files</TD></TR><TR CLASS="c"><TD CLASS="l">530</TD><TD>                if (arg.startsWith(&#34;-&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">531</TD><TD>                    System.err.println(&#34;**Unknown option: &#34; + arg);</TD></TR><TR><TD CLASS="l">532</TD><TD>                } else {  // treat as input file</TD></TR><TR CLASS="c"><TD CLASS="l">533</TD><TD>                    fileList.add(arg);</TD></TR><TR><TD CLASS="l">534</TD><TD>                }</TD></TR><TR><TD CLASS="l">535</TD><TD>            }</TD></TR><TR><TD CLASS="l">536</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">537</TD><TD>        if (argList.size() &gt; 0) {  // check for unprocessed args</TD></TR><TR CLASS="z"><TD CLASS="l">538</TD><TD>            System.err.println(&#34;**Unprocessed arguments?! &#34; + argList.toString());</TD></TR><TR><TD CLASS="l">539</TD><TD>        }</TD></TR><TR><TD CLASS="l">540</TD><TD> </TD></TR><TR><TD CLASS="l">541</TD><TD>        // for backward compat: make sure system properties are checked</TD></TR><TR CLASS="c"><TD CLASS="l">542</TD><TD>        optIgnoreDupXmiIDs |= Util.getSysBoolWithDefault(PROP_IGNORE_DUP_IDS, false);</TD></TR><TR CLASS="c"><TD CLASS="l">543</TD><TD>        optNoTrace |= Util.getSysBoolWithDefault(PROP_NO_TRACE, false);</TD></TR><TR CLASS="c"><TD CLASS="l">544</TD><TD>        optQualifySignals |= Util.getSysBoolWithDefault(PROP_QUALIFY_SIGNALS, false);</TD></TR><TR CLASS="c"><TD CLASS="l">545</TD><TD>        if (Boolean.valueOf(System.getProperty(PROP_TARGET_C)) == true) {</TD></TR><TR><TD CLASS="l">546</TD><TD>            // add (to front of list) non-template version C as gen target</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>            propGenTargets.add(0, Kind.CNonTemplate);</TD></TR><TR><TD CLASS="l">548</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">549</TD><TD>    }</TD></TR><TR><TD CLASS="l">550</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="4">551</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">552</TD><TD>     * Prints the application version.</TD></TR><TR><TD CLASS="l">553</TD><TD>     */</TD></TR><TR><TD CLASS="l">554</TD><TD>    private void printVersionAndExit () {</TD></TR><TR CLASS="z"><TD CLASS="l">555</TD><TD>        System.out.println(&#34;JPL Autocoder version &#34; + AC_VERSION);</TD></TR><TR CLASS="z"><TD CLASS="l">556</TD><TD>        System.out.printf(AC_COPYRIGHTS, Calendar.getInstance().get(Calendar.YEAR));</TD></TR><TR CLASS="z"><TD CLASS="l">557</TD><TD>        System.out.println();</TD></TR><TR CLASS="z"><TD CLASS="l">558</TD><TD>        System.out.println(&#34;ALL RIGHTS RESERVED. U.S. Government Sponsorship acknowledged.&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>        System.exit(-1);</TD></TR><TR CLASS="z"><TD CLASS="l">560</TD><TD>    }</TD></TR><TR><TD CLASS="l">561</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="3">562</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">563</TD><TD>     * Prints the usage and exits application.</TD></TR><TR><TD CLASS="l">564</TD><TD>     */</TD></TR><TR><TD CLASS="l">565</TD><TD>    private void printUsageAndExit () {</TD></TR><TR CLASS="z"><TD CLASS="l">566</TD><TD>        final String NEWL = System.getProperty(&#34;line.separator&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">567</TD><TD>        final String PAD = &#34;    &#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>        int len2ExtraTab = 8-PAD.length();  // to determine if extra tab needed </TD></TR><TR><TD CLASS="l">569</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">570</TD><TD>        String cmdStr = System.getenv(&#34;0&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">571</TD><TD>        if (cmdStr == null) {  // use our own default</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>            cmdStr = &#34;java -jar &lt;path&gt;/autocoder.jar&#34;;</TD></TR><TR><TD CLASS="l">573</TD><TD>        }</TD></TR><TR><TD CLASS="l">574</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>        System.err.println();</TD></TR><TR CLASS="z"><TD CLASS="l">576</TD><TD>        System.err.println(&#34;Usage:&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">577</TD><TD>        System.err.println(PAD + cmdStr + &#34; &lt;generator&gt;+ [&lt;option&gt;]* &lt;file.xml&gt;+&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">578</TD><TD>        System.err.println(PAD + cmdStr + &#34; &#34; + OPT_USAGE + &#34; | &#34; + OPT_VERSION);</TD></TR><TR CLASS="z"><TD CLASS="l">579</TD><TD>        System.err.println();</TD></TR><TR CLASS="z"><TD CLASS="l">580</TD><TD>        System.err.println(&#34;Generators supported (^ mean unavailable in classpath):&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">581</TD><TD>        for (Map.Entry&lt;String,Kind&gt; optEntry : opt2GenKindMap.entrySet()) {</TD></TR><TR CLASS="z"><TD CLASS="l">582</TD><TD>            String optStr = optEntry.getKey();</TD></TR><TR CLASS="z"><TD CLASS="l">583</TD><TD>            Kind genKind = optEntry.getValue();</TD></TR><TR CLASS="z"><TD CLASS="l">584</TD><TD>            String append = &#34;&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">585</TD><TD>            if (!generatorMap.containsKey(genKind)) {  // autocoder supports it</TD></TR><TR CLASS="z"><TD CLASS="l">586</TD><TD>                append += &#34;^&#34;;</TD></TR><TR><TD CLASS="l">587</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">588</TD><TD>            if (optStr.length() &lt; len2ExtraTab) {</TD></TR><TR CLASS="z"><TD CLASS="l">589</TD><TD>                append += &#34;\t&#34;;</TD></TR><TR><TD CLASS="l">590</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">591</TD><TD>            System.err.println(PAD + optStr + append + &#34;\t\t&#34; + genKind.label());</TD></TR><TR><TD CLASS="l">592</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">593</TD><TD>        System.err.println();</TD></TR><TR CLASS="z"><TD CLASS="l">594</TD><TD>        System.err.println(&#34;Options, switch default is FALSE if not set (^ means as-yet-unimplemented):&#34;);</TD></TR><TR><TD CLASS="l">595</TD><TD>//        System.err.println(PAD + OPT_</TD></TR><TR><TD CLASS="l">596</TD><TD>//                + &#34;\t\t\t&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">597</TD><TD>        System.err.println(PAD + OPT_USAGE</TD></TR><TR><TD CLASS="l">598</TD><TD>                + &#34;\t\t\tprint this usage help and exit&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">599</TD><TD>        System.err.println(PAD + OPT_DEBUG</TD></TR><TR><TD CLASS="l">600</TD><TD>                + &#34;\t\tenable Autocoder debug output&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">601</TD><TD>        System.err.println(PAD + OPT_DUP_SM</TD></TR><TR><TD CLASS="l">602</TD><TD>                + &#34;\tallow duplicate StateMachine names&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">603</TD><TD>        System.err.println(PAD + OPT_IGNORE_DUP_IDS</TD></TR><TR CLASS="z"><TD CLASS="l">604</TD><TD>                + &#34;\tignore duplicate XMI IDs,&#34; + NEWL</TD></TR><TR CLASS="z"><TD CLASS="l">605</TD><TD>                + &#34;\t\t\tuseful when generating signals from multiple input files&#34; + NEWL</TD></TR><TR CLASS="z"><TD CLASS="l">606</TD><TD>                + &#34;\t\t\t(VM prop: -D&#34; + PROP_IGNORE_DUP_IDS + &#34;=true)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">607</TD><TD>        System.err.println(PAD + OPT_IMPL_CALLS</TD></TR><TR><TD CLASS="l">608</TD><TD>                + &#34;\t\tactivate implementation function calls&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">609</TD><TD>        System.err.println(PAD + OPT_NO_TRACE</TD></TR><TR CLASS="z"><TD CLASS="l">610</TD><TD>                + &#34;\t\tturn transition execution trace off&#34; + NEWL</TD></TR><TR CLASS="z"><TD CLASS="l">611</TD><TD>                + &#34;\t\t\t(equiv. VM prop: -D&#34; + PROP_NO_TRACE + &#34;=true)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">612</TD><TD>        System.err.println(PAD + OPT_QUALIFY_SIGNALS</TD></TR><TR CLASS="z"><TD CLASS="l">613</TD><TD>                + &#34;\tprint fully-qualified signal names (deprecated?!)&#34; + NEWL</TD></TR><TR CLASS="z"><TD CLASS="l">614</TD><TD>                + &#34;\t\t\t(VM prop: -D&#34; + PROP_QUALIFY_SIGNALS + &#34;=true)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">615</TD><TD>        System.err.println(PAD + OPT_STATE_MACHINE</TD></TR><TR><TD CLASS="l">616</TD><TD>                + &#34; &lt;SM_i&gt;\t\tgenerate a specific State Machine (may use 1+ times)&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">617</TD><TD>        System.err.println(PAD + OPT_VERBOSE</TD></TR><TR><TD CLASS="l">618</TD><TD>                + &#34;\t\tenable verbose Autocoder output&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">619</TD><TD>        System.err.println(PAD + OPT_VERSION</TD></TR><TR><TD CLASS="l">620</TD><TD>                + &#34;\t\tprint product version &amp; copyrights and exit&#34;);</TD></TR><TR CLASS="z"><TD CLASS="l">621</TD><TD>        System.err.println();</TD></TR><TR><TD CLASS="l">622</TD><TD> </TD></TR><TR><TD CLASS="l">623</TD><TD>        // terminate upon printing usage</TD></TR><TR CLASS="z"><TD CLASS="l">624</TD><TD>        System.exit(-1);</TD></TR><TR CLASS="z"><TD CLASS="l">625</TD><TD>    }</TD></TR><TR><TD CLASS="l">626</TD><TD> </TD></TR><TR><TD CLASS="l">627</TD><TD> </TD></TR><TR><TD CLASS="l">628</TD><TD>    /**</TD></TR><TR><TD CLASS="l">629</TD><TD>     * Main method for the StateChart Autocoders application.  Parses arguments</TD></TR><TR><TD CLASS="l">630</TD><TD>     * to determine what target programming language to generate.</TD></TR><TR><TD CLASS="l"><A NAME="1a">631</A></TD><TD>     * </TD></TR><TR><TD CLASS="l">632</TD><TD>     * @param args  command-line arguments</TD></TR><TR><TD CLASS="l">633</TD><TD>     */</TD></TR><TR><TD CLASS="l">634</TD><TD>    public static void main (String[] args) {</TD></TR><TR CLASS="c"><TD CLASS="l">635</TD><TD>        Autocoder autocoder = Autocoder.inst();</TD></TR><TR CLASS="c"><TD CLASS="l">636</TD><TD>        autocoder.init(args);</TD></TR><TR CLASS="c"><TD CLASS="l">637</TD><TD>        autocoder.generate();</TD></TR><TR CLASS="c"><TD CLASS="l">638</TD><TD>        autocoder.dispose();</TD></TR><TR CLASS="c"><TD CLASS="l">639</TD><TD>    }</TD></TR><TR><TD CLASS="l">640</TD><TD> </TD></TR><TR><TD CLASS="l">641</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="a.html">gov.nasa.jpl.statechart</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>