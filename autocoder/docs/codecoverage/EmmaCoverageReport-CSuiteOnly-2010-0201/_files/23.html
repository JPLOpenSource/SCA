<HTML><HEAD><META CONTENT="text/html; charset=UTF-8" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://www.eclemma.org/">EMMA</A> Coverage Report (generated Mon Feb 01 15:58:17 PST 2010)</TH></TR><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="4.html">gov.nasa.jpl.statechart.template</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">AbstractVelocityModel.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>AbstractVelocityModel.java</TD><TD CLASS="h">50%  (1/2)</TD><TD CLASS="h">36%  (16/44)</TD><TD CLASS="h">26%  (210/822)</TD><TD CLASS="h">29%  (56.5/196)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">AbstractVelocityModel$1</A></TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/2)</TD><TD CLASS="h">0%   (0/29)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#0">AbstractVelocityModel$1 (AbstractVelocityModel, boolean): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/10)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">visit (State): void</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/19)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD><TD CLASS="bt"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#3">AbstractVelocityModel</A></TD><TD>100% (1/1)</TD><TD CLASS="h">38%  (16/42)</TD><TD CLASS="h">26%  (210/793)</TD><TD CLASS="h">30%  (56.5/188)</TD></TR><TR><TD CLASS="f"><A HREF="#4">getCallActionsOfVertex (Vertex): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#5">getCallParts (Behavior): FunctionCall</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#6">getCallParts (OpaqueExpression): FunctionCall</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/6)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#7">getDesiredEvents (StateMachine): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/39)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#8">getFinalStates (Namespace): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#9">getInitialState (Namespace): Pseudostate</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/69)</TD><TD CLASS="h">0%   (0/15)</TD></TR><TR><TD CLASS="f"><A HREF="#a">getInitialTransition (Pseudostate): Transition</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/34)</TD><TD CLASS="h">0%   (0/10)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#b">getJunctionTransitions (Pseudostate): List</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/62)</TD><TD CLASS="h">0%   (0/14)</TD></TR><TR><TD CLASS="f"><A HREF="#c">getOwnedEvents (StateMachine): List</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/45)</TD><TD CLASS="h">0%   (0/13)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#d">getParentState (NamedElement): NamedElement</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/21)</TD><TD CLASS="h">0%   (0/9)</TD></TR><TR><TD CLASS="f"><A HREF="#e">getStates (Namespace): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/5)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#f">getStates (Namespace, boolean): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#10">getSubmachines (Namespace): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#11">getTarget (Vertex, Transition): Vertex</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#12">getTimeEvents (Vertex): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#13">getTransitionSignalEvents (Namespace): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/25)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR><TD CLASS="f"><A HREF="#14">getTransitionTimeEvents (Namespace): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/23)</TD><TD CLASS="h">0%   (0/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#15">getTransitionsWithEvent (Vertex): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/24)</TD><TD CLASS="h">0%   (0/5)</TD></TR><TR><TD CLASS="f"><A HREF="#16">getTransitionsWithSignalEvent (Namespace, boolean): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#17">getTransitionsWithTimeEvent (Namespace, boolean): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#18">getVertices (Namespace, boolean): Collection</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/8)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#19">hasDoActivity (State): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/12)</TD><TD CLASS="h">0%   (0/1)</TD></TR><TR><TD CLASS="f"><A HREF="#1a">hasDoActivity (StateMachine): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/14)</TD><TD CLASS="h">0%   (0/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1b">hasGuard (Transition): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/27)</TD><TD CLASS="h">0%   (0/8)</TD></TR><TR><TD CLASS="f"><A HREF="#1c">isAncestorRegion (State, Region): boolean</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/26)</TD><TD CLASS="h">0%   (0/7)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1d">timestamp (): String</A></TD><TD> </TD><TD CLASS="h">0%   (0/1)</TD><TD CLASS="h">0%   (0/15)</TD><TD CLASS="h">0%   (0/3)</TD></TR><TR><TD CLASS="f"><A HREF="#1e">getType (NamedElement): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">63%  (32/51)</TD><TD CLASS="h">53%  (9/17)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#1f">getEnclosingOrthogonalRegion (Vertex): Region</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (28/30)</TD><TD>95%  (9.5/10)</TD></TR><TR><TD CLASS="f"><A HREF="#3">AbstractVelocityModel (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#21">addToSet (Set, Collection): Set</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (18/18)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#22">getCallActions (Namespace, boolean): Collection</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (30/30)</TD><TD>100% (8/8)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#23">getCallParts (String): FunctionCall</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#24">getParentOrthogonalState (Vertex): State</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>100% (2/2)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#25">getSubmachineStates (Namespace): Collection</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (8/8)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#26">isCallAction (String): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#27">makeSet (): Set</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#28">removeFromSet (Set, Collection): Set</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (21/21)</TD><TD>100% (6/6)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#29">sort (Collection): SortedSet</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR><TD CLASS="f"><A HREF="#2a">sort (Map): SortedMap</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (5/5)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2b">sortBySignal (Collection): List</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (24/24)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="f"><A HREF="#2c">toHexString (int, int): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (4/4)</TD><TD>100% (1/1)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2d">username (): String</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (3/3)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" WIDTH="100%" CELLSPACING="0"><TR CLASS="z"><TD CLASS="l"><A NAME="0">1</A></TD><TD>/**</TD></TR><TR><TD CLASS="l">2</TD><TD> * Created Sep 28, 2009.</TD></TR><TR><TD CLASS="l">3</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">4</TD><TD> * Copyright 2009, by the California Institute of Technology. ALL RIGHTS</TD></TR><TR><TD CLASS="l">5</TD><TD> * RESERVED. United States Government Sponsorship acknowledged. Any commercial</TD></TR><TR><TD CLASS="l">6</TD><TD> * use must be negotiated with the Office of Technology Transfer at the</TD></TR><TR><TD CLASS="l">7</TD><TD> * California Institute of Technology.</TD></TR><TR><TD CLASS="l">8</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">9</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">10</TD><TD> * This software is subject to U.S. export control laws and regulations and has</TD></TR><TR><TD CLASS="l">11</TD><TD> * been classified as 4D993. By accepting this software, the user agrees to</TD></TR><TR><TD CLASS="l">12</TD><TD> * comply with all applicable U.S. export laws and regulations. User has the</TD></TR><TR><TD CLASS="l">13</TD><TD> * responsibility to obtain export licenses, or other export authority as may be</TD></TR><TR><TD CLASS="l">14</TD><TD> * required before exporting such information to foreign countries or providing</TD></TR><TR><TD CLASS="l">15</TD><TD> * access to foreign persons.</TD></TR><TR><TD CLASS="l">16</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">17</TD><TD> */</TD></TR><TR><TD CLASS="l">18</TD><TD>package gov.nasa.jpl.statechart.template;</TD></TR><TR><TD CLASS="l">19</TD><TD> </TD></TR><TR><TD CLASS="l">20</TD><TD>import gov.nasa.jpl.statechart.Util;</TD></TR><TR><TD CLASS="l">21</TD><TD>import gov.nasa.jpl.statechart.model.PrefixOrderedWalker;</TD></TR><TR><TD CLASS="l">22</TD><TD>import gov.nasa.jpl.statechart.model.visitor.AbstractVisitor;</TD></TR><TR><TD CLASS="l">23</TD><TD>import gov.nasa.jpl.statechart.model.visitor.CallActionVisitor;</TD></TR><TR><TD CLASS="l">24</TD><TD>import gov.nasa.jpl.statechart.model.visitor.FinalStateVisitor;</TD></TR><TR><TD CLASS="l">25</TD><TD>import gov.nasa.jpl.statechart.model.visitor.StateVisitor;</TD></TR><TR><TD CLASS="l">26</TD><TD>import gov.nasa.jpl.statechart.model.visitor.SubmachineStateVisitor;</TD></TR><TR><TD CLASS="l">27</TD><TD>import gov.nasa.jpl.statechart.model.visitor.SubmachineVisitor;</TD></TR><TR><TD CLASS="l">28</TD><TD>import gov.nasa.jpl.statechart.model.visitor.TransitionSignalEventVisitor;</TD></TR><TR><TD CLASS="l">29</TD><TD>import gov.nasa.jpl.statechart.model.visitor.TransitionTimeEventVisitor;</TD></TR><TR><TD CLASS="l">30</TD><TD>import gov.nasa.jpl.statechart.model.visitor.VertexVisitor;</TD></TR><TR><TD CLASS="l">31</TD><TD>import gov.nasa.jpl.statechart.uml.Behavior;</TD></TR><TR><TD CLASS="l">32</TD><TD>import gov.nasa.jpl.statechart.uml.ConnectionPointReference;</TD></TR><TR><TD CLASS="l">33</TD><TD>import gov.nasa.jpl.statechart.uml.Element;</TD></TR><TR><TD CLASS="l">34</TD><TD>import gov.nasa.jpl.statechart.uml.Event;</TD></TR><TR><TD CLASS="l">35</TD><TD>import gov.nasa.jpl.statechart.uml.FinalState;</TD></TR><TR><TD CLASS="l">36</TD><TD>import gov.nasa.jpl.statechart.uml.NamedElement;</TD></TR><TR><TD CLASS="l">37</TD><TD>import gov.nasa.jpl.statechart.uml.Namespace;</TD></TR><TR><TD CLASS="l">38</TD><TD>import gov.nasa.jpl.statechart.uml.OpaqueExpression;</TD></TR><TR><TD CLASS="l">39</TD><TD>import gov.nasa.jpl.statechart.uml.Pseudostate;</TD></TR><TR><TD CLASS="l">40</TD><TD>import gov.nasa.jpl.statechart.uml.PseudostateKind;</TD></TR><TR><TD CLASS="l">41</TD><TD>import gov.nasa.jpl.statechart.uml.Region;</TD></TR><TR><TD CLASS="l">42</TD><TD>import gov.nasa.jpl.statechart.uml.SignalEvent;</TD></TR><TR><TD CLASS="l">43</TD><TD>import gov.nasa.jpl.statechart.uml.State;</TD></TR><TR><TD CLASS="l">44</TD><TD>import gov.nasa.jpl.statechart.uml.StateMachine;</TD></TR><TR><TD CLASS="l">45</TD><TD>import gov.nasa.jpl.statechart.uml.TimeEvent;</TD></TR><TR><TD CLASS="l">46</TD><TD>import gov.nasa.jpl.statechart.uml.Transition;</TD></TR><TR><TD CLASS="l">47</TD><TD>import gov.nasa.jpl.statechart.uml.UMLElement;</TD></TR><TR><TD CLASS="l">48</TD><TD>import gov.nasa.jpl.statechart.uml.Vertex;</TD></TR><TR><TD CLASS="l">49</TD><TD> </TD></TR><TR><TD CLASS="l">50</TD><TD>import java.text.SimpleDateFormat;</TD></TR><TR><TD CLASS="l">51</TD><TD>import java.util.ArrayList;</TD></TR><TR><TD CLASS="l">52</TD><TD>import java.util.Calendar;</TD></TR><TR><TD CLASS="l">53</TD><TD>import java.util.Collection;</TD></TR><TR><TD CLASS="l">54</TD><TD>import java.util.Collections;</TD></TR><TR><TD CLASS="l">55</TD><TD>import java.util.LinkedHashSet;</TD></TR><TR><TD CLASS="l">56</TD><TD>import java.util.List;</TD></TR><TR><TD CLASS="l">57</TD><TD>import java.util.Map;</TD></TR><TR><TD CLASS="l">58</TD><TD>import java.util.Set;</TD></TR><TR><TD CLASS="l">59</TD><TD>import java.util.SortedMap;</TD></TR><TR><TD CLASS="l">60</TD><TD>import java.util.SortedSet;</TD></TR><TR><TD CLASS="l">61</TD><TD>import java.util.TreeMap;</TD></TR><TR><TD CLASS="l">62</TD><TD>import java.util.TreeSet;</TD></TR><TR><TD CLASS="l">63</TD><TD> </TD></TR><TR><TD CLASS="l">64</TD><TD>import javax.xml.xpath.XPathConstants;</TD></TR><TR><TD CLASS="l">65</TD><TD>import javax.xml.xpath.XPathExpressionException;</TD></TR><TR><TD CLASS="l">66</TD><TD> </TD></TR><TR><TD CLASS="l">67</TD><TD>import org.w3c.dom.NodeList;</TD></TR><TR><TD CLASS="l">68</TD><TD> </TD></TR><TR><TD CLASS="l">69</TD><TD>/**</TD></TR><TR><TD CLASS="l">70</TD><TD> * Abstract base class for Velocity Models.</TD></TR><TR><TD CLASS="l">71</TD><TD> * &lt;p&gt;</TD></TR><TR><TD CLASS="l">72</TD><TD> * Copyright &amp;copy; 2009 Jet Propulsion Lab / California Institute of Technology</TD></TR><TR><TD CLASS="l">73</TD><TD> * &lt;/p&gt;</TD></TR><TR><TD CLASS="l">74</TD><TD> * @author Shang-Wen Cheng &lt;scheng@jpl.nasa.gov&gt; refactored from old VelocityModel</TD></TR><TR><TD CLASS="l">75</TD><TD> */</TD></TR><TR><TD CLASS="l">76</TD><TD>public abstract class AbstractVelocityModel {</TD></TR><TR><TD CLASS="l"><A NAME="3">77</A></TD><TD> </TD></TR><TR><TD CLASS="l">78</TD><TD>    /**</TD></TR><TR><TD CLASS="l">79</TD><TD>     * Main constructor.</TD></TR><TR><TD CLASS="l">80</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">81</TD><TD>    public AbstractVelocityModel () {</TD></TR><TR><TD CLASS="l">82</TD><TD>        // does nothing</TD></TR><TR CLASS="c"><TD CLASS="l">83</TD><TD>    }</TD></TR><TR><TD CLASS="l">84</TD><TD> </TD></TR><TR><TD CLASS="l">85</TD><TD> </TD></TR><TR><TD CLASS="l">86</TD><TD>    /**</TD></TR><TR><TD CLASS="l">87</TD><TD>     * Returns a string identifying the type of object by taking the lowercase</TD></TR><TR><TD CLASS="l">88</TD><TD>     * of the type name.  For UML Pseudostates, this is equal to string</TD></TR><TR><TD CLASS="l">89</TD><TD>     * &#34;pseudostate:kind&#34; where &#34;kind&#34; is the Kind of the pseudostate.</TD></TR><TR><TD CLASS="l">90</TD><TD>     * Other examples are &#34;state&#34; for States, &#34;region&#34; for regions, </TD></TR><TR><TD CLASS="l">91</TD><TD>     * &#34;statemachine&#34; for state machine nodes, etc.</TD></TR><TR><TD CLASS="l">92</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="1e">93</A></TD><TD>     * @param ne  UML NamedElement</TD></TR><TR><TD CLASS="l">94</TD><TD>     * @return a string representing the type of this element</TD></TR><TR><TD CLASS="l">95</TD><TD>     */</TD></TR><TR><TD CLASS="l">96</TD><TD>    public String getType (NamedElement ne) {</TD></TR><TR CLASS="c"><TD CLASS="l">97</TD><TD>        if (ne instanceof Pseudostate) {</TD></TR><TR CLASS="c"><TD CLASS="l">98</TD><TD>            return &#34;pseudostate:&#34; + ((Pseudostate) ne).getKind().name();</TD></TR><TR><TD CLASS="l">99</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">100</TD><TD>        if (ne instanceof FinalState) {</TD></TR><TR CLASS="z"><TD CLASS="l">101</TD><TD>            return &#34;finalState&#34;;</TD></TR><TR><TD CLASS="l">102</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">103</TD><TD>        if (ne instanceof State) {</TD></TR><TR CLASS="c"><TD CLASS="l">104</TD><TD>            return &#34;state&#34;;</TD></TR><TR><TD CLASS="l">105</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">106</TD><TD>        if (ne instanceof Region) {</TD></TR><TR CLASS="c"><TD CLASS="l">107</TD><TD>            return &#34;region&#34;;</TD></TR><TR><TD CLASS="l">108</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">109</TD><TD>        if (ne instanceof StateMachine) {</TD></TR><TR CLASS="c"><TD CLASS="l">110</TD><TD>            return &#34;statemachine&#34;;</TD></TR><TR><TD CLASS="l">111</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">112</TD><TD>        if (ne instanceof ConnectionPointReference) {</TD></TR><TR CLASS="z"><TD CLASS="l">113</TD><TD>            return &#34;connectionPointReference&#34;;</TD></TR><TR><TD CLASS="l">114</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">115</TD><TD>        if (ne instanceof Behavior) {</TD></TR><TR CLASS="z"><TD CLASS="l">116</TD><TD>            return &#34;behavior&#34;;</TD></TR><TR><TD CLASS="l">117</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">118</TD><TD>        if (ne instanceof OpaqueExpression) {</TD></TR><TR CLASS="z"><TD CLASS="l">119</TD><TD>            return &#34;opaqueexpression&#34;;</TD></TR><TR><TD CLASS="l">120</TD><TD>        }</TD></TR><TR><TD CLASS="l">121</TD><TD>        // careful! this returns the most specific subtype</TD></TR><TR><TD CLASS="l">122</TD><TD>//        return ne.getClass().getSimpleName().toLowerCase();</TD></TR><TR CLASS="z"><TD CLASS="l">123</TD><TD>        return &#34;unknown&#34;;</TD></TR><TR><TD CLASS="l">124</TD><TD>    }</TD></TR><TR><TD CLASS="l">125</TD><TD> </TD></TR><TR><TD CLASS="l">126</TD><TD>    /**</TD></TR><TR><TD CLASS="l">127</TD><TD>     * Returns a collection of States, which refer to sub-StateMachines,</TD></TR><TR><TD CLASS="l">128</TD><TD>     * within the supplied Namespace.</TD></TR><TR><TD CLASS="l">129</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="25">130</A></TD><TD>     * @param ns  UML Namespace within which to look for submachine states.</TD></TR><TR><TD CLASS="l">131</TD><TD>     * @return  Collection of UML States that refer to submachines.</TD></TR><TR><TD CLASS="l">132</TD><TD>     */</TD></TR><TR><TD CLASS="l">133</TD><TD>    public Collection&lt;State&gt; getSubmachineStates (Namespace ns) {</TD></TR><TR CLASS="c"><TD CLASS="l">134</TD><TD>        return PrefixOrderedWalker.traverse(ns, new SubmachineStateVisitor(true));</TD></TR><TR><TD CLASS="l">135</TD><TD>    }</TD></TR><TR><TD CLASS="l">136</TD><TD> </TD></TR><TR><TD CLASS="l">137</TD><TD>    /**</TD></TR><TR><TD CLASS="l">138</TD><TD>     * Returns a collection of Submachines from submachine States</TD></TR><TR><TD CLASS="l">139</TD><TD>     * within the supplied Namespace.</TD></TR><TR><TD CLASS="l">140</TD><TD>     *</TD></TR><TR><TD CLASS="l"><A NAME="10">141</A></TD><TD>     * @param ns  UML Namespace within which to look for submachine states.</TD></TR><TR><TD CLASS="l">142</TD><TD>     * @return  Collection of UML StateMachines.</TD></TR><TR><TD CLASS="l">143</TD><TD>     */</TD></TR><TR><TD CLASS="l">144</TD><TD>    public Collection&lt;StateMachine&gt; getSubmachines (Namespace ns) {</TD></TR><TR CLASS="z"><TD CLASS="l">145</TD><TD>        return PrefixOrderedWalker.traverse(ns, new SubmachineVisitor(true));</TD></TR><TR><TD CLASS="l">146</TD><TD>    }</TD></TR><TR><TD CLASS="l">147</TD><TD> </TD></TR><TR><TD CLASS="l">148</TD><TD>    /**</TD></TR><TR><TD CLASS="l">149</TD><TD>     * Checks whether the supplied Region is an ancestor region of the</TD></TR><TR><TD CLASS="l">150</TD><TD>     * supplied State.</TD></TR><TR><TD CLASS="l">151</TD><TD>     * @param state   UML State to check</TD></TR><TR><TD CLASS="l">152</TD><TD>     * @param region  UML Region to check</TD></TR><TR><TD CLASS="l"><A NAME="1c">153</A></TD><TD>     * @return &lt;code&gt;true&lt;/code&gt; if Region is in the ancestor axis of the State;</TD></TR><TR><TD CLASS="l">154</TD><TD>     *   &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">155</TD><TD>     */</TD></TR><TR><TD CLASS="l">156</TD><TD>    public boolean isAncestorRegion (State state, Region r) {</TD></TR><TR CLASS="z"><TD CLASS="l">157</TD><TD>        Region ancestorRegion = state.getContainer();</TD></TR><TR CLASS="z"><TD CLASS="l">158</TD><TD>        while (ancestorRegion != null &amp;&amp; ancestorRegion != r) {</TD></TR><TR CLASS="z"><TD CLASS="l">159</TD><TD>            State parentState = ancestorRegion.getState();</TD></TR><TR CLASS="z"><TD CLASS="l">160</TD><TD>            if (parentState != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">161</TD><TD>                ancestorRegion = parentState.getContainer();</TD></TR><TR><TD CLASS="l">162</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">163</TD><TD>                ancestorRegion = null;</TD></TR><TR><TD CLASS="l">164</TD><TD>            }</TD></TR><TR><TD CLASS="l">165</TD><TD>        }</TD></TR><TR><TD CLASS="l">166</TD><TD>        // ancestor region IS the supplied region if not NULL</TD></TR><TR CLASS="z"><TD CLASS="l">167</TD><TD>        return ancestorRegion != null;</TD></TR><TR><TD CLASS="l">168</TD><TD>    }</TD></TR><TR><TD CLASS="l">169</TD><TD> </TD></TR><TR><TD CLASS="l">170</TD><TD>    /**</TD></TR><TR><TD CLASS="l">171</TD><TD>     * Returns the enclosing orthogonal region of a given state, or null if</TD></TR><TR><TD CLASS="l">172</TD><TD>     * state NOT within an orthogonal region.</TD></TR><TR><TD CLASS="l">173</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="1f">174</A></TD><TD>     * @param state  the state whose enclosing orthogonal region is sought</TD></TR><TR><TD CLASS="l">175</TD><TD>     * @return the enclosing Region</TD></TR><TR><TD CLASS="l">176</TD><TD>     */</TD></TR><TR><TD CLASS="l">177</TD><TD>    public Region getEnclosingOrthogonalRegion (Vertex state) {</TD></TR><TR CLASS="p"><TD TITLE="50% line coverage (2 out of 4 instructions)" CLASS="l">178</TD><TD TITLE="50% line coverage (2 out of 4 instructions)">        if (state == null) return null;</TD></TR><TR><TD CLASS="l">179</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">180</TD><TD>        State parent = null;</TD></TR><TR CLASS="c"><TD CLASS="l">181</TD><TD>        Region region = state.getContainer();</TD></TR><TR><TD CLASS="l">182</TD><TD>        // Loop Invariant:  stop when found parent OR exhausted parent region</TD></TR><TR CLASS="c"><TD CLASS="l">183</TD><TD>        while (parent == null &amp;&amp; region != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">184</TD><TD>            parent = region.getState();  // parent state of region</TD></TR><TR CLASS="c"><TD CLASS="l">185</TD><TD>            if (parent != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">186</TD><TD>                if (parent.isOrthogonal()) {</TD></TR><TR><TD CLASS="l">187</TD><TD>                    // that's it, found desired enclosing region!</TD></TR><TR><TD CLASS="l">188</TD><TD>                } else {  // try further up</TD></TR><TR CLASS="c"><TD CLASS="l">189</TD><TD>                    region = parent.getContainer();</TD></TR><TR><TD CLASS="l">190</TD><TD>                }</TD></TR><TR><TD CLASS="l">191</TD><TD>            } else {  // can't go up anymore</TD></TR><TR CLASS="c"><TD CLASS="l">192</TD><TD>                region = null;</TD></TR><TR><TD CLASS="l">193</TD><TD>            }</TD></TR><TR><TD CLASS="l">194</TD><TD>        }</TD></TR><TR><TD CLASS="l">195</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">196</TD><TD>        return region;</TD></TR><TR><TD CLASS="l">197</TD><TD>    }</TD></TR><TR><TD CLASS="l">198</TD><TD> </TD></TR><TR><TD CLASS="l">199</TD><TD>    /**</TD></TR><TR><TD CLASS="l">200</TD><TD>     * Collects and returns descendant states without descending into</TD></TR><TR><TD CLASS="l">201</TD><TD>     * submachines, self included if a State.</TD></TR><TR><TD CLASS="l">202</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="e">203</A></TD><TD>     * @param ns  UML Namespace whose descendant states to get.</TD></TR><TR><TD CLASS="l">204</TD><TD>     * @return  Collection of contained {@link State}.</TD></TR><TR><TD CLASS="l">205</TD><TD>     */</TD></TR><TR><TD CLASS="l">206</TD><TD>    public Collection&lt;State&gt; getStates (Namespace ns) {</TD></TR><TR CLASS="z"><TD CLASS="l">207</TD><TD>        return getStates(ns, false);</TD></TR><TR><TD CLASS="l">208</TD><TD>    }</TD></TR><TR><TD CLASS="l">209</TD><TD> </TD></TR><TR><TD CLASS="l">210</TD><TD>    /**</TD></TR><TR><TD CLASS="l">211</TD><TD>     * Collects and returns descendant states, self included if a State. </TD></TR><TR><TD CLASS="l">212</TD><TD>     * </TD></TR><TR><TD CLASS="l">213</TD><TD>     * @param ns  UML Namespace whose descendant states to get.</TD></TR><TR><TD CLASS="l"><A NAME="f">214</A></TD><TD>     * @param descend  flag indicating whether to descend into submachines.</TD></TR><TR><TD CLASS="l">215</TD><TD>     * @return  Collection of contained {@link State}.</TD></TR><TR><TD CLASS="l">216</TD><TD>     */</TD></TR><TR><TD CLASS="l">217</TD><TD>    public Collection&lt;State&gt; getStates (Namespace ns, boolean descend) {</TD></TR><TR CLASS="z"><TD CLASS="l">218</TD><TD>        return PrefixOrderedWalker.traverse(ns, new StateVisitor(descend));</TD></TR><TR><TD CLASS="l">219</TD><TD>    }</TD></TR><TR><TD CLASS="l">220</TD><TD> </TD></TR><TR><TD CLASS="l">221</TD><TD>    /**</TD></TR><TR><TD CLASS="l">222</TD><TD>     * Collects and returns descendant vertices, including Pseudostates and</TD></TR><TR><TD CLASS="l">223</TD><TD>     * States.</TD></TR><TR><TD CLASS="l">224</TD><TD>     * </TD></TR><TR><TD CLASS="l">225</TD><TD>     * @param ns  UML Namespace whose descendant vertices to get.</TD></TR><TR><TD CLASS="l"><A NAME="18">226</A></TD><TD>     * @param descend  flag indicating whether to descend into submachines.</TD></TR><TR><TD CLASS="l">227</TD><TD>     * @return  Collection of contained {@link Vertex}.</TD></TR><TR><TD CLASS="l">228</TD><TD>     */</TD></TR><TR><TD CLASS="l">229</TD><TD>    public Collection&lt;Vertex&gt; getVertices (Namespace ns, boolean descend) {</TD></TR><TR CLASS="z"><TD CLASS="l">230</TD><TD>        return PrefixOrderedWalker.traverse(ns, new VertexVisitor(descend));</TD></TR><TR><TD CLASS="l">231</TD><TD>    }</TD></TR><TR><TD CLASS="l">232</TD><TD> </TD></TR><TR><TD CLASS="l">233</TD><TD>    /**</TD></TR><TR><TD CLASS="l">234</TD><TD>     * Returns the parent state, or StateMachine, of this NamedElement,</TD></TR><TR><TD CLASS="l"><A NAME="d">235</A></TD><TD>     * or null if top of model reached.</TD></TR><TR><TD CLASS="l">236</TD><TD>     * @return the parent State or StateMachine NamedElement.</TD></TR><TR><TD CLASS="l">237</TD><TD>     */</TD></TR><TR><TD CLASS="l">238</TD><TD>    public NamedElement getParentState (NamedElement ne) {</TD></TR><TR CLASS="z"><TD CLASS="l">239</TD><TD>        NamedElement parent = null;</TD></TR><TR><TD CLASS="l">240</TD><TD>        // loop invariant:  terminate when ne == null</TD></TR><TR CLASS="z"><TD CLASS="l">241</TD><TD>        while (ne != null) {</TD></TR><TR CLASS="z"><TD CLASS="l">242</TD><TD>            parent = ne.getParent();</TD></TR><TR CLASS="z"><TD CLASS="l">243</TD><TD>            if (parent instanceof State</TD></TR><TR CLASS="z"><TD CLASS="l">244</TD><TD>                    || parent instanceof StateMachine) {</TD></TR><TR><TD CLASS="l">245</TD><TD>                // we're golden</TD></TR><TR CLASS="z"><TD CLASS="l">246</TD><TD>                break;</TD></TR><TR><TD CLASS="l">247</TD><TD>            } else {</TD></TR><TR CLASS="z"><TD CLASS="l">248</TD><TD>                ne = parent;</TD></TR><TR><TD CLASS="l">249</TD><TD>                // null out parent to prevent returning a wrong element</TD></TR><TR CLASS="z"><TD CLASS="l">250</TD><TD>                parent = null;</TD></TR><TR><TD CLASS="l">251</TD><TD>            }</TD></TR><TR><TD CLASS="l">252</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">253</TD><TD>        return parent;</TD></TR><TR><TD CLASS="l">254</TD><TD>    }</TD></TR><TR><TD CLASS="l">255</TD><TD> </TD></TR><TR><TD CLASS="l">256</TD><TD>    /**</TD></TR><TR><TD CLASS="l">257</TD><TD>     * Returns the nearest enclosing orthogonal state, or null if none.</TD></TR><TR><TD CLASS="l"><A NAME="24">258</A></TD><TD>     * @param v  the State for which to find nearest enclosing orthogonal state</TD></TR><TR><TD CLASS="l">259</TD><TD>     * @return the parent State of an enclosing orthogonal region, if any.</TD></TR><TR><TD CLASS="l">260</TD><TD>     */</TD></TR><TR><TD CLASS="l">261</TD><TD>    public State getParentOrthogonalState (Vertex state) {</TD></TR><TR CLASS="c"><TD CLASS="l">262</TD><TD>        Region parent = getEnclosingOrthogonalRegion(state);</TD></TR><TR CLASS="c"><TD CLASS="l">263</TD><TD>        return (parent == null) ? null : parent.getState();</TD></TR><TR><TD CLASS="l">264</TD><TD>    }</TD></TR><TR><TD CLASS="l">265</TD><TD> </TD></TR><TR><TD CLASS="l">266</TD><TD>    /**</TD></TR><TR><TD CLASS="l">267</TD><TD>     * Returns a collection of {@link FinalState}s within supplied namespace.</TD></TR><TR><TD CLASS="l">268</TD><TD>     * No descent into submachine is necessary as the submachines should take</TD></TR><TR><TD CLASS="l">269</TD><TD>     * care of their own final state reseting.</TD></TR><TR><TD CLASS="l">270</TD><TD>     * @param ns  Namespace within which to search for FinalStates.</TD></TR><TR><TD CLASS="l"><A NAME="8">271</A></TD><TD>     * @return  Collection of UML {@link FinalState}.</TD></TR><TR><TD CLASS="l">272</TD><TD>     */</TD></TR><TR><TD CLASS="l">273</TD><TD>    public Collection&lt;FinalState&gt; getFinalStates (Namespace ns) {</TD></TR><TR><TD CLASS="l">274</TD><TD>        // don't need to descend into submachines</TD></TR><TR CLASS="z"><TD CLASS="l">275</TD><TD>        return PrefixOrderedWalker.traverse(ns, new FinalStateVisitor(false));</TD></TR><TR><TD CLASS="l">276</TD><TD>    }</TD></TR><TR><TD CLASS="l">277</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="12">278</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">279</TD><TD>     * Returns the set of TimeEvents that trigger transition from a particular state.</TD></TR><TR><TD CLASS="l">280</TD><TD>     */</TD></TR><TR><TD CLASS="l">281</TD><TD>    public Collection&lt;TimeEvent&gt; getTimeEvents (Vertex state) {</TD></TR><TR CLASS="z"><TD CLASS="l">282</TD><TD>        List&lt;TimeEvent&gt; events = new ArrayList&lt;TimeEvent&gt;();</TD></TR><TR><TD CLASS="l">283</TD><TD>        // For each transition out of the state, examine its triggers</TD></TR><TR><TD CLASS="l">284</TD><TD>        // and keep the time event triggers</TD></TR><TR CLASS="z"><TD CLASS="l">285</TD><TD>        for (Transition transition : state.getOutgoing()) {</TD></TR><TR CLASS="z"><TD CLASS="l">286</TD><TD>            events.addAll(transition.getTimeEvents());</TD></TR><TR><TD CLASS="l">287</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">288</TD><TD>        return events;</TD></TR><TR><TD CLASS="l">289</TD><TD>    }</TD></TR><TR><TD CLASS="l">290</TD><TD> </TD></TR><TR><TD CLASS="l">291</TD><TD>    /**</TD></TR><TR><TD CLASS="l">292</TD><TD>     * Returns a list of transitions with either SignalEvents or TimeEvents</TD></TR><TR><TD CLASS="l"><A NAME="15">293</A></TD><TD>     * trigger out of the given UML State.</TD></TR><TR><TD CLASS="l">294</TD><TD>     * @param state  the UML state for which to compute transition events.</TD></TR><TR><TD CLASS="l">295</TD><TD>     */</TD></TR><TR><TD CLASS="l">296</TD><TD>    public Collection&lt;Transition&gt; getTransitionsWithEvent (Vertex state) {</TD></TR><TR CLASS="z"><TD CLASS="l">297</TD><TD>        List&lt;Transition&gt; trans = Util.newList();</TD></TR><TR><TD CLASS="l">298</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">299</TD><TD>        for (Transition transition : state.getOutgoing()) {</TD></TR><TR CLASS="z"><TD CLASS="l">300</TD><TD>            if (transition.getAllEvents().size() &gt; 0) {</TD></TR><TR CLASS="z"><TD CLASS="l">301</TD><TD>                trans.add(transition);</TD></TR><TR><TD CLASS="l">302</TD><TD>            }</TD></TR><TR><TD CLASS="l">303</TD><TD>        }</TD></TR><TR><TD CLASS="l">304</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">305</TD><TD>        return trans;</TD></TR><TR><TD CLASS="l">306</TD><TD>    }</TD></TR><TR><TD CLASS="l">307</TD><TD> </TD></TR><TR><TD CLASS="l">308</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="17">309</A></TD><TD>     * Returns the set of Transitions from a particular namespace whose trigger is</TD></TR><TR><TD CLASS="l">310</TD><TD>     * a time event.</TD></TR><TR><TD CLASS="l">311</TD><TD>     */</TD></TR><TR><TD CLASS="l">312</TD><TD>    public Collection&lt;Transition&gt; getTransitionsWithTimeEvent (Namespace ns, boolean descend) {</TD></TR><TR CLASS="z"><TD CLASS="l">313</TD><TD>        return PrefixOrderedWalker.traverse(ns, new TransitionTimeEventVisitor(descend));</TD></TR><TR><TD CLASS="l">314</TD><TD>    }</TD></TR><TR><TD CLASS="l">315</TD><TD> </TD></TR><TR><TD CLASS="l">316</TD><TD>    /**</TD></TR><TR><TD CLASS="l"><A NAME="16">317</A></TD><TD>     * Returns the set of Transitions from a particular namespace whose trigger is</TD></TR><TR><TD CLASS="l">318</TD><TD>     * a signal event.</TD></TR><TR><TD CLASS="l">319</TD><TD>     */</TD></TR><TR><TD CLASS="l">320</TD><TD>    public Collection&lt;Transition&gt; getTransitionsWithSignalEvent (Namespace ns, boolean descend) {</TD></TR><TR CLASS="z"><TD CLASS="l">321</TD><TD>        return PrefixOrderedWalker.traverse(ns, new TransitionSignalEventVisitor(descend));</TD></TR><TR><TD CLASS="l">322</TD><TD>    }</TD></TR><TR><TD CLASS="l">323</TD><TD> </TD></TR><TR><TD CLASS="l">324</TD><TD>    /**</TD></TR><TR><TD CLASS="l">325</TD><TD>     * Returns a sorted list of unique signal events for all the transitions in</TD></TR><TR><TD CLASS="l">326</TD><TD>     * the supplied Namespace.</TD></TR><TR><TD CLASS="l">327</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="13">328</A></TD><TD>     * @param ns  Namespace whose transitions to examine.</TD></TR><TR><TD CLASS="l">329</TD><TD>     * @return  List of {@link SignalEvent}s sorted by name.</TD></TR><TR><TD CLASS="l">330</TD><TD>     */</TD></TR><TR><TD CLASS="l">331</TD><TD>    public Collection&lt;SignalEvent&gt; getTransitionSignalEvents (Namespace ns) {</TD></TR><TR CLASS="z"><TD CLASS="l">332</TD><TD>        Set&lt;SignalEvent&gt; signalEvents = Util.newSet();</TD></TR><TR><TD CLASS="l">333</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>        for (Transition transition : getTransitionsWithSignalEvent(ns, true)) {</TD></TR><TR CLASS="z"><TD CLASS="l">335</TD><TD>            signalEvents.addAll(transition.getSignalEvents());</TD></TR><TR><TD CLASS="l">336</TD><TD>        }</TD></TR><TR><TD CLASS="l">337</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">338</TD><TD>        return sortBySignal(signalEvents);</TD></TR><TR><TD CLASS="l">339</TD><TD>    }</TD></TR><TR><TD CLASS="l">340</TD><TD> </TD></TR><TR><TD CLASS="l">341</TD><TD>    /**</TD></TR><TR><TD CLASS="l">342</TD><TD>     * Returns a unique list of time events for all the transitions in the</TD></TR><TR><TD CLASS="l">343</TD><TD>     * supplied Namespace.</TD></TR><TR><TD CLASS="l">344</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="14">345</A></TD><TD>     * @param ns  Namespace whose transitions to examine.</TD></TR><TR><TD CLASS="l">346</TD><TD>     * @return  List of {@link TimeEvent}s.</TD></TR><TR><TD CLASS="l">347</TD><TD>     */</TD></TR><TR><TD CLASS="l">348</TD><TD>    public Collection&lt;TimeEvent&gt; getTransitionTimeEvents (Namespace ns) {</TD></TR><TR CLASS="z"><TD CLASS="l">349</TD><TD>        Set&lt;TimeEvent&gt; timeEvents = Util.newSet();</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">351</TD><TD>        for (Transition transition : getTransitionsWithTimeEvent(ns, true)) {</TD></TR><TR CLASS="z"><TD CLASS="l">352</TD><TD>            timeEvents.addAll(transition.getTimeEvents());</TD></TR><TR><TD CLASS="l">353</TD><TD>        }</TD></TR><TR><TD CLASS="l">354</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">355</TD><TD>        return timeEvents;</TD></TR><TR><TD CLASS="l">356</TD><TD>    }</TD></TR><TR><TD CLASS="l">357</TD><TD> </TD></TR><TR><TD CLASS="l">358</TD><TD>    /**</TD></TR><TR><TD CLASS="l">359</TD><TD>     * Returns the set of transitions from a Junction pseudostate, ordered so</TD></TR><TR><TD CLASS="l">360</TD><TD>     * that the last one is the &#34;else&#34;, the branch without a guard (or has</TD></TR><TR><TD CLASS="l">361</TD><TD>     * a guard with the sole words &#34;else&#34; or &#34;no&#34;, case-insensitive).</TD></TR><TR><TD CLASS="l"><A NAME="b">362</A></TD><TD>     * @param entry</TD></TR><TR><TD CLASS="l">363</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">364</TD><TD>     */</TD></TR><TR><TD CLASS="l">365</TD><TD>    public List&lt;Transition&gt; getJunctionTransitions (Pseudostate pseudo) {</TD></TR><TR CLASS="z"><TD CLASS="l">366</TD><TD>        SortedMap&lt;String,Transition&gt; specTransMap = new TreeMap&lt;String,Transition&gt;();</TD></TR><TR CLASS="z"><TD CLASS="l">367</TD><TD>        Transition elseBranch = null;</TD></TR><TR CLASS="z"><TD CLASS="l">368</TD><TD>        for (Transition trans : pseudo.getOutgoing()) {</TD></TR><TR CLASS="z"><TD CLASS="l">369</TD><TD>            if (hasGuard(trans)) {</TD></TR><TR><TD CLASS="l">370</TD><TD>                // get the spec text to sort the transitions by spec</TD></TR><TR CLASS="z"><TD CLASS="l">371</TD><TD>                String spec = trans.getGuard().getSpecification().getBody();</TD></TR><TR CLASS="z"><TD CLASS="l">372</TD><TD>                specTransMap.put(spec, trans);  // add guarded transition</TD></TR><TR><TD CLASS="l">373</TD><TD>            } else {</TD></TR><TR><TD CLASS="l">374</TD><TD>                // save elseGuard for last in list</TD></TR><TR CLASS="z"><TD CLASS="l">375</TD><TD>                if (elseBranch != null) {  // uh oh! already one else branch!</TD></TR><TR CLASS="z"><TD CLASS="l">376</TD><TD>                    Util.error(&#34;ERROR! More than one default branch in junction/choice '&#34;</TD></TR><TR CLASS="z"><TD CLASS="l">377</TD><TD>                            + pseudo.getQualifiedName() + &#34;'!&#34;);</TD></TR><TR><TD CLASS="l">378</TD><TD>                } else {</TD></TR><TR CLASS="z"><TD CLASS="l">379</TD><TD>                    elseBranch = trans;</TD></TR><TR><TD CLASS="l">380</TD><TD>                }</TD></TR><TR><TD CLASS="l">381</TD><TD>            }</TD></TR><TR><TD CLASS="l">382</TD><TD>        }</TD></TR><TR><TD CLASS="l">383</TD><TD> </TD></TR><TR><TD CLASS="l">384</TD><TD>        // now obtain sorted transition list from the map</TD></TR><TR CLASS="z"><TD CLASS="l">385</TD><TD>        List&lt;Transition&gt; transList = Util.newList();</TD></TR><TR CLASS="z"><TD CLASS="l">386</TD><TD>        transList.addAll(specTransMap.values());</TD></TR><TR><TD CLASS="l">387</TD><TD>        // add the noGuard transition; null as placeholder if none</TD></TR><TR CLASS="z"><TD CLASS="l">388</TD><TD>        transList.add(elseBranch);</TD></TR><TR><TD CLASS="l">389</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">390</TD><TD>        return transList;</TD></TR><TR><TD CLASS="l">391</TD><TD>    }</TD></TR><TR><TD CLASS="l">392</TD><TD> </TD></TR><TR><TD CLASS="l">393</TD><TD>    /**</TD></TR><TR><TD CLASS="l">394</TD><TD>     * Returns whether the supplied transition has a valid guard, which means</TD></TR><TR><TD CLASS="l">395</TD><TD>     * a non-null guard object that has non-empty specification body AND</TD></TR><TR><TD CLASS="l">396</TD><TD>     * the spec is not &#34;else&#34; or &#34;no&#34; (case-insensitive).</TD></TR><TR><TD CLASS="l">397</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="1b">398</A></TD><TD>     * @param trans  UML Transition</TD></TR><TR><TD CLASS="l">399</TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if transition has a valid guard, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">400</TD><TD>     */</TD></TR><TR><TD CLASS="l">401</TD><TD>    public boolean hasGuard (Transition trans) {</TD></TR><TR CLASS="z"><TD CLASS="l">402</TD><TD>        boolean rv = false;</TD></TR><TR CLASS="z"><TD CLASS="l">403</TD><TD>        if (trans.getGuard() != null) {  // non-null guard object</TD></TR><TR CLASS="z"><TD CLASS="l">404</TD><TD>            String specBody = trans.getGuard().getSpecification().getBody();</TD></TR><TR CLASS="z"><TD CLASS="l">405</TD><TD>            if (specBody != null &amp;&amp; specBody.length() &gt; 0</TD></TR><TR CLASS="z"><TD CLASS="l">406</TD><TD>                    &amp;&amp; !&#34;else&#34;.equalsIgnoreCase(specBody)</TD></TR><TR CLASS="z"><TD CLASS="l">407</TD><TD>                    &amp;&amp; !&#34;no&#34;.equalsIgnoreCase(specBody)) {</TD></TR><TR><TD CLASS="l">408</TD><TD>                // valid, non-zero-length specification body AND not 'else'</TD></TR><TR CLASS="z"><TD CLASS="l">409</TD><TD>                rv = true;</TD></TR><TR><TD CLASS="l">410</TD><TD>            }</TD></TR><TR><TD CLASS="l">411</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">412</TD><TD>        return rv;</TD></TR><TR><TD CLASS="l">413</TD><TD>    }</TD></TR><TR><TD CLASS="l">414</TD><TD> </TD></TR><TR><TD CLASS="l">415</TD><TD>    /**</TD></TR><TR><TD CLASS="l">416</TD><TD>     * Returns the collection of Signal or Time Events that a StateMachine</TD></TR><TR><TD CLASS="l">417</TD><TD>     * is interested in.</TD></TR><TR><TD CLASS="l"><A NAME="7">418</A></TD><TD>     * @param sm  UML StateMachine whose events of interest to collect</TD></TR><TR><TD CLASS="l">419</TD><TD>     * @return  Collection of UML Events the StateMachine has interest in.</TD></TR><TR><TD CLASS="l">420</TD><TD>     */</TD></TR><TR><TD CLASS="l">421</TD><TD>    public Collection&lt;Event&gt; getDesiredEvents (StateMachine sm) {</TD></TR><TR CLASS="z"><TD CLASS="l">422</TD><TD>        List&lt;Event&gt; events = Util.newList();</TD></TR><TR><TD CLASS="l">423</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">424</TD><TD>        for (State state : PrefixOrderedWalker.traverse(sm, new StateVisitor(true))) {</TD></TR><TR CLASS="z"><TD CLASS="l">425</TD><TD>            for (Transition transition : getTransitionsWithEvent(state)) {</TD></TR><TR CLASS="z"><TD CLASS="l">426</TD><TD>                events.addAll(transition.getAllEvents());</TD></TR><TR><TD CLASS="l">427</TD><TD>            }</TD></TR><TR><TD CLASS="l">428</TD><TD>        }</TD></TR><TR><TD CLASS="l">429</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">430</TD><TD>        return events;</TD></TR><TR><TD CLASS="l">431</TD><TD>    }</TD></TR><TR><TD CLASS="l">432</TD><TD> </TD></TR><TR><TD CLASS="l">433</TD><TD>    /**</TD></TR><TR><TD CLASS="l">434</TD><TD>     * Returns the initial state for a region, state or statemachine.  The</TD></TR><TR><TD CLASS="l">435</TD><TD>     * states are always contained in region.  If we are given a</TD></TR><TR><TD CLASS="l">436</TD><TD>     * statemachine or state, we look for a region.  If there is more than</TD></TR><TR><TD CLASS="l"><A NAME="9">437</A></TD><TD>     * one region, throw an exception.</TD></TR><TR><TD CLASS="l">438</TD><TD>     */</TD></TR><TR><TD CLASS="l">439</TD><TD>    public Pseudostate getInitialState (Namespace ns) {</TD></TR><TR><TD CLASS="l">440</TD><TD>        // There must be a region, but we'll let StateMachine and State pass, too.</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>        if (ns instanceof StateMachine) {</TD></TR><TR CLASS="z"><TD CLASS="l">442</TD><TD>            Collection&lt;Region&gt; regions = ((StateMachine) ns).getRegion();</TD></TR><TR CLASS="z"><TD CLASS="l">443</TD><TD>            if (regions.size() != 1) return null;</TD></TR><TR><TD CLASS="l">444</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">445</TD><TD>            ns = regions.iterator().next();</TD></TR><TR><TD CLASS="l">446</TD><TD>        }</TD></TR><TR><TD CLASS="l">447</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">448</TD><TD>        if (ns instanceof State) {</TD></TR><TR CLASS="z"><TD CLASS="l">449</TD><TD>            Collection&lt;Region&gt; regions = ((State) ns).getRegion();</TD></TR><TR CLASS="z"><TD CLASS="l">450</TD><TD>            if (regions.size() != 1) return null;</TD></TR><TR><TD CLASS="l">451</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">452</TD><TD>            ns = regions.iterator().next();</TD></TR><TR><TD CLASS="l">453</TD><TD>        }</TD></TR><TR><TD CLASS="l">454</TD><TD> </TD></TR><TR><TD CLASS="l">455</TD><TD>        // Now, we should have a region, if not return null</TD></TR><TR CLASS="z"><TD CLASS="l">456</TD><TD>        if (ns instanceof Region) {</TD></TR><TR CLASS="z"><TD CLASS="l">457</TD><TD>            for (Vertex subvertex : ((Region) ns).getSubvertex()) {</TD></TR><TR CLASS="z"><TD CLASS="l">458</TD><TD>                if (!(subvertex instanceof Pseudostate)) continue;</TD></TR><TR><TD CLASS="l">459</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">460</TD><TD>                Pseudostate ps = (Pseudostate) subvertex;</TD></TR><TR><TD CLASS="l">461</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">462</TD><TD>                if (!ps.getKind().equals(PseudostateKind.initial)) continue;</TD></TR><TR><TD CLASS="l">463</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">464</TD><TD>                return ps;</TD></TR><TR><TD CLASS="l">465</TD><TD>            }</TD></TR><TR><TD CLASS="l">466</TD><TD>        }</TD></TR><TR><TD CLASS="l">467</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">468</TD><TD>        return null;</TD></TR><TR><TD CLASS="l">469</TD><TD>    }</TD></TR><TR><TD CLASS="l">470</TD><TD> </TD></TR><TR><TD CLASS="l">471</TD><TD>    /**</TD></TR><TR><TD CLASS="l">472</TD><TD>     * Returns the initial transition from a Pseudostate, or null if none found</TD></TR><TR><TD CLASS="l">473</TD><TD>     * (and print error message!)</TD></TR><TR><TD CLASS="l"><A NAME="a">474</A></TD><TD>     * @param pseudo  UML Pseudostate to find initial transition from</TD></TR><TR><TD CLASS="l">475</TD><TD>     * @return  UML Transition that represents the initial transition</TD></TR><TR><TD CLASS="l">476</TD><TD>     */</TD></TR><TR><TD CLASS="l">477</TD><TD>    public Transition getInitialTransition (Pseudostate pseudo) {</TD></TR><TR CLASS="z"><TD CLASS="l">478</TD><TD>        if (pseudo == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">479</TD><TD>            Util.error(&#34;Error! Supplied initial state was NULL!&#34;);</TD></TR><TR><TD CLASS="l">480</TD><TD>            // TODO should we throw exception, print stack trace, or something??</TD></TR><TR CLASS="z"><TD CLASS="l">481</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">482</TD><TD>        }</TD></TR><TR><TD CLASS="l">483</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">484</TD><TD>        Collection&lt;Transition&gt; transList = pseudo.getOutgoing();</TD></TR><TR CLASS="z"><TD CLASS="l">485</TD><TD>        if (transList.size() == 0) {  // error should already be reported</TD></TR><TR CLASS="z"><TD CLASS="l">486</TD><TD>            return null;</TD></TR><TR><TD CLASS="l">487</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">488</TD><TD>        if (transList.size() &gt; 1) {</TD></TR><TR CLASS="z"><TD CLASS="l">489</TD><TD>            Util.error(&#34;Initial state &#34; + pseudo.getQualifiedName()</TD></TR><TR CLASS="z"><TD CLASS="l">490</TD><TD>                    + &#34; has more than one outgoing transition! I'm picking the first transition, but you might not get the right behavior.&#34;);</TD></TR><TR><TD CLASS="l">491</TD><TD>        }</TD></TR><TR><TD CLASS="l">492</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">493</TD><TD>        return transList.iterator().next();</TD></TR><TR><TD CLASS="l">494</TD><TD>    }</TD></TR><TR><TD CLASS="l">495</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="11">496</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">497</TD><TD>     * Given a source state and a transition, returns the target state.</TD></TR><TR><TD CLASS="l">498</TD><TD>     */</TD></TR><TR><TD CLASS="l">499</TD><TD>    public Vertex getTarget (Vertex source, Transition transition) {</TD></TR><TR CLASS="z"><TD CLASS="l">500</TD><TD>        Vertex target = transition.getTarget();</TD></TR><TR CLASS="z"><TD CLASS="l">501</TD><TD>        if (!source.equals(transition.getSource())) {</TD></TR><TR CLASS="z"><TD CLASS="l">502</TD><TD>            throw new RuntimeException(&#34;Passed source does not match transition source&#34;);</TD></TR><TR><TD CLASS="l">503</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">504</TD><TD>        return target;</TD></TR><TR><TD CLASS="l">505</TD><TD>    }</TD></TR><TR><TD CLASS="l">506</TD><TD> </TD></TR><TR><TD CLASS="l">507</TD><TD>    // cache of call actions by a starting UML Namespace tree-vertex</TD></TR><TR CLASS="c"><TD CLASS="l">508</TD><TD>    private Map&lt;Namespace,Collection&lt;FunctionCall&gt;&gt; funcsForNamespace = Util.newMap();</TD></TR><TR><TD CLASS="l">509</TD><TD> </TD></TR><TR><TD CLASS="l">510</TD><TD>    /**</TD></TR><TR><TD CLASS="l">511</TD><TD>     * Returns a Collection of call-actions in the model tree, descending from</TD></TR><TR><TD CLASS="l">512</TD><TD>     * the given Namespace, down into children regardless of orthogonal regions.</TD></TR><TR><TD CLASS="l">513</TD><TD>     * The call-actions are returned as {@link FunctionCall} objects for query</TD></TR><TR><TD CLASS="l">514</TD><TD>     * convenience.</TD></TR><TR><TD CLASS="l">515</TD><TD>     * </TD></TR><TR><TD CLASS="l">516</TD><TD>     * @param ns  UML Namespace object to descend from.</TD></TR><TR><TD CLASS="l"><A NAME="22">517</A></TD><TD>     * @param descend  whether to descend into Submachines.</TD></TR><TR><TD CLASS="l">518</TD><TD>     * @return  Collection of FunctionCall objects.</TD></TR><TR><TD CLASS="l">519</TD><TD>     */</TD></TR><TR><TD CLASS="l">520</TD><TD>    public Collection&lt;FunctionCall&gt; getCallActions (Namespace ns, boolean descend) {</TD></TR><TR CLASS="c"><TD CLASS="l">521</TD><TD>        Collection&lt;FunctionCall&gt; rv = funcsForNamespace.get(ns);</TD></TR><TR CLASS="c"><TD CLASS="l">522</TD><TD>        if (rv == null) {  // walk tree and store outcome in cache map</TD></TR><TR CLASS="c"><TD CLASS="l">523</TD><TD>            CallActionVisitor v = new CallActionVisitor(descend, true);</TD></TR><TR CLASS="c"><TD CLASS="l">524</TD><TD>            PrefixOrderedWalker.traverse(ns, v);</TD></TR><TR CLASS="c"><TD CLASS="l">525</TD><TD>            Collections.sort(v);</TD></TR><TR CLASS="c"><TD CLASS="l">526</TD><TD>            funcsForNamespace.put(ns, v);</TD></TR><TR CLASS="c"><TD CLASS="l">527</TD><TD>            rv = v;</TD></TR><TR><TD CLASS="l">528</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">529</TD><TD>        return rv;</TD></TR><TR><TD CLASS="l">530</TD><TD>    }</TD></TR><TR><TD CLASS="l">531</TD><TD> </TD></TR><TR><TD CLASS="l">532</TD><TD>    /**</TD></TR><TR><TD CLASS="l">533</TD><TD>     * Returns the call actions for just one state or pseudostate; the</TD></TR><TR><TD CLASS="l">534</TD><TD>     * underlying visitor will look at the state itself and its outgoing</TD></TR><TR><TD CLASS="l">535</TD><TD>     * transitions only; inner states are not visited.</TD></TR><TR><TD CLASS="l">536</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="4">537</A></TD><TD>     * @param vertex  UML Pseudostate or State in which to search for call actions.</TD></TR><TR><TD CLASS="l">538</TD><TD>     * @return  Collection of FunctionCall objects.</TD></TR><TR><TD CLASS="l">539</TD><TD>     */</TD></TR><TR><TD CLASS="l">540</TD><TD>    public Collection&lt;FunctionCall&gt; getCallActionsOfVertex (Vertex vertex) {</TD></TR><TR CLASS="z"><TD CLASS="l">541</TD><TD>        CallActionVisitor v = new CallActionVisitor(false, false);</TD></TR><TR CLASS="z"><TD CLASS="l">542</TD><TD>        if (vertex instanceof State) {</TD></TR><TR CLASS="z"><TD CLASS="l">543</TD><TD>            v.visit((State) vertex);</TD></TR><TR CLASS="z"><TD CLASS="l">544</TD><TD>        } else if (vertex instanceof Pseudostate) {</TD></TR><TR CLASS="z"><TD CLASS="l">545</TD><TD>            v.visit((Pseudostate) vertex);</TD></TR><TR><TD CLASS="l">546</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l">547</TD><TD>        return v;</TD></TR><TR><TD CLASS="l">548</TD><TD>    }</TD></TR><TR><TD CLASS="l">549</TD><TD> </TD></TR><TR><TD CLASS="l">550</TD><TD>    /**</TD></TR><TR><TD CLASS="l">551</TD><TD>     * Returns whether the StateMachine contains any state with Do activity.</TD></TR><TR><TD CLASS="l">552</TD><TD>     * The Visitor stops searching (but will still visit the entire model tree)</TD></TR><TR><TD CLASS="l">553</TD><TD>     * as soon as one is found.</TD></TR><TR><TD CLASS="l">554</TD><TD>     * </TD></TR><TR><TD CLASS="l"><A NAME="1a">555</A></TD><TD>     * @param sm  UML StateMachine to search for Do activity.</TD></TR><TR><TD CLASS="l">556</TD><TD>     * @return  &lt;code&gt;true&lt;/code&gt; if any state has Do activity, &lt;code&gt;false&lt;/code&gt; otherwise.</TD></TR><TR><TD CLASS="l">557</TD><TD>     */</TD></TR><TR><TD CLASS="l">558</TD><TD>    public boolean hasDoActivity (StateMachine sm) {</TD></TR><TR CLASS="z"><TD CLASS="l">559</TD><TD>        return PrefixOrderedWalker.traverse(sm, new AbstractVisitor&lt;Boolean&gt;(false) {</TD></TR><TR><TD CLASS="l"><A NAME="2">560</A></TD><TD>            private static final long serialVersionUID = 1612572786346429584L;</TD></TR><TR CLASS="z"><TD CLASS="l">561</TD><TD>            private boolean foundDoActivity = false;</TD></TR><TR><TD CLASS="l">562</TD><TD>            @Override</TD></TR><TR><TD CLASS="l">563</TD><TD>            public void visit (State state) {</TD></TR><TR CLASS="z"><TD CLASS="l">564</TD><TD>                if (foundDoActivity) return;</TD></TR><TR CLASS="z"><TD CLASS="l">565</TD><TD>                if (hasDoActivity(state)) {</TD></TR><TR><TD CLASS="l">566</TD><TD>                    // found one, done!</TD></TR><TR CLASS="z"><TD CLASS="l">567</TD><TD>                    add(true);</TD></TR><TR CLASS="z"><TD CLASS="l">568</TD><TD>                    foundDoActivity = true;</TD></TR><TR CLASS="z"><TD CLASS="l">569</TD><TD>                    return;</TD></TR><TR><TD CLASS="l">570</TD><TD>                }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="19">571</A></TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">572</TD><TD>        }).size() &gt; 0;</TD></TR><TR><TD CLASS="l">573</TD><TD>    }</TD></TR><TR><TD CLASS="l">574</TD><TD>    public boolean hasDoActivity (State state) {</TD></TR><TR CLASS="z"><TD CLASS="l">575</TD><TD>        return state.getDo() != null &amp;&amp; state.getDo().actionList().size() &gt; 0; </TD></TR><TR><TD CLASS="l">576</TD><TD>    }</TD></TR><TR><TD CLASS="l">577</TD><TD> </TD></TR><TR><TD CLASS="l">578</TD><TD> </TD></TR><TR><TD CLASS="l">579</TD><TD>    /////////////////////////////////////////////////</TD></TR><TR><TD CLASS="l"><A NAME="26">580</A></TD><TD>    // Utility methods for manipulating model parts</TD></TR><TR><TD CLASS="l">581</TD><TD>    /////////////////////////////////////////////////</TD></TR><TR><TD CLASS="l">582</TD><TD> </TD></TR><TR><TD CLASS="l">583</TD><TD>    public boolean isCallAction (String exprStr) {</TD></TR><TR CLASS="c"><TD CLASS="l">584</TD><TD>        return Util.isFunctionCall(exprStr);</TD></TR><TR><TD CLASS="l">585</TD><TD>    }</TD></TR><TR><TD CLASS="l">586</TD><TD> </TD></TR><TR><TD CLASS="l">587</TD><TD>    /**</TD></TR><TR><TD CLASS="l">588</TD><TD>     * Returns the call action function object containing name and args.</TD></TR><TR><TD CLASS="l"><A NAME="5">589</A></TD><TD>     * @param beh  Behavior object (entry, exit, do, etc.)</TD></TR><TR><TD CLASS="l">590</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">591</TD><TD>     */</TD></TR><TR><TD CLASS="l">592</TD><TD>    public FunctionCall getCallParts (Behavior beh) {</TD></TR><TR CLASS="z"><TD CLASS="l">593</TD><TD>        return new FunctionCall(beh.getName());</TD></TR><TR><TD CLASS="l">594</TD><TD>    }</TD></TR><TR><TD CLASS="l">595</TD><TD> </TD></TR><TR><TD CLASS="l">596</TD><TD>    /**</TD></TR><TR><TD CLASS="l">597</TD><TD>     * Returns the call function object containing name and args.</TD></TR><TR><TD CLASS="l"><A NAME="6">598</A></TD><TD>     * @param spec  Expression spec object (mostly for transition guards)</TD></TR><TR><TD CLASS="l">599</TD><TD>     * @return</TD></TR><TR><TD CLASS="l">600</TD><TD>     */</TD></TR><TR><TD CLASS="l">601</TD><TD>    public FunctionCall getCallParts (OpaqueExpression spec) {</TD></TR><TR CLASS="z"><TD CLASS="l">602</TD><TD>        return new FunctionCall(spec.getBody());</TD></TR><TR><TD CLASS="l">603</TD><TD>    }</TD></TR><TR><TD CLASS="l">604</TD><TD> </TD></TR><TR><TD CLASS="l">605</TD><TD>    /**</TD></TR><TR><TD CLASS="l">606</TD><TD>     * Common method that takes a string, presumably a method call, and returns</TD></TR><TR><TD CLASS="l">607</TD><TD>     * a {@link FunctionCall} object containing its name and optional args.</TD></TR><TR><TD CLASS="l"><A NAME="23">608</A></TD><TD>     * @param exprStr  expression String to parse</TD></TR><TR><TD CLASS="l">609</TD><TD>     * @return  {@link FunctionCall} object</TD></TR><TR><TD CLASS="l">610</TD><TD>     */</TD></TR><TR><TD CLASS="l">611</TD><TD>    public FunctionCall getCallParts (String exprStr) {</TD></TR><TR CLASS="c"><TD CLASS="l">612</TD><TD>        return new FunctionCall(exprStr);</TD></TR><TR><TD CLASS="l">613</TD><TD>    }</TD></TR><TR><TD CLASS="l">614</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="2a">615</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">616</TD><TD>     * Sort a collection of named elements by qualified name using a {@link SortedMap}.</TD></TR><TR><TD CLASS="l">617</TD><TD>     */</TD></TR><TR><TD CLASS="l">618</TD><TD>    public &lt;T extends NamedElement&gt; SortedMap&lt;String, T&gt; sort (Map&lt;String, T&gt; map) {</TD></TR><TR CLASS="c"><TD CLASS="l">619</TD><TD>        return new TreeMap&lt;String, T&gt;(map);</TD></TR><TR><TD CLASS="l">620</TD><TD>    }</TD></TR><TR><TD CLASS="l">621</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="29">622</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">623</TD><TD>     * Sort a collection of named elements by elements alone.</TD></TR><TR><TD CLASS="l">624</TD><TD>     */</TD></TR><TR><TD CLASS="l">625</TD><TD>    public &lt;T extends NamedElement&gt; SortedSet&lt;T&gt; sort (Collection&lt;T&gt; elements) {</TD></TR><TR CLASS="c"><TD CLASS="l">626</TD><TD>        return new TreeSet&lt;T&gt;(elements);</TD></TR><TR><TD CLASS="l">627</TD><TD>    }</TD></TR><TR><TD CLASS="l">628</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="2b">629</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">630</TD><TD>     * Sort a collection of signal events by their signal names</TD></TR><TR><TD CLASS="l">631</TD><TD>     */</TD></TR><TR><TD CLASS="l">632</TD><TD>    public List&lt;SignalEvent&gt; sortBySignal (Collection&lt;SignalEvent&gt; events) {</TD></TR><TR CLASS="c"><TD CLASS="l">633</TD><TD>        SortedMap&lt;String,SignalEvent&gt; nameEventMap = Util.newSortedMap();</TD></TR><TR CLASS="c"><TD CLASS="l">634</TD><TD>        for (SignalEvent ev : events) {</TD></TR><TR CLASS="c"><TD CLASS="l">635</TD><TD>            nameEventMap.put(ev.getSignal().getName(), ev);</TD></TR><TR><TD CLASS="l">636</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="27">637</A></TD><TD>        return Util.newList(nameEventMap.values());</TD></TR><TR><TD CLASS="l">638</TD><TD>    }</TD></TR><TR><TD CLASS="l">639</TD><TD> </TD></TR><TR><TD CLASS="l">640</TD><TD>    public Set&lt;NamedElement&gt; makeSet () {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="21">641</A></TD><TD>        return new LinkedHashSet&lt;NamedElement&gt;();</TD></TR><TR><TD CLASS="l">642</TD><TD>    }</TD></TR><TR><TD CLASS="l">643</TD><TD> </TD></TR><TR><TD CLASS="l">644</TD><TD>    public Set&lt;NamedElement&gt; addToSet (Set&lt;NamedElement&gt; set, Collection&lt;NamedElement&gt; toAdd) {</TD></TR><TR CLASS="c"><TD CLASS="l">645</TD><TD>        Set&lt;NamedElement&gt; newSet = new LinkedHashSet&lt;NamedElement&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">646</TD><TD>        if (set != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">647</TD><TD>            newSet.addAll(set);</TD></TR><TR><TD CLASS="l">648</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">649</TD><TD>        if (toAdd != null) {</TD></TR><TR CLASS="c"><TD CLASS="l">650</TD><TD>            newSet.addAll(toAdd);</TD></TR><TR><TD CLASS="l">651</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="28">652</A></TD><TD>        return newSet;</TD></TR><TR><TD CLASS="l">653</TD><TD>    }</TD></TR><TR><TD CLASS="l">654</TD><TD> </TD></TR><TR><TD CLASS="l">655</TD><TD>    public Set&lt;NamedElement&gt; removeFromSet (Set&lt;NamedElement&gt; set, Collection&lt;NamedElement&gt; toRemove) {</TD></TR><TR CLASS="c"><TD CLASS="l">656</TD><TD>        Set&lt;NamedElement&gt; newSet = new LinkedHashSet&lt;NamedElement&gt;();</TD></TR><TR CLASS="c"><TD CLASS="l">657</TD><TD>        if (set != null &amp;&amp; !set.isEmpty()) {  // first, add source set to new set</TD></TR><TR CLASS="c"><TD CLASS="l">658</TD><TD>            newSet.addAll(set);</TD></TR><TR CLASS="c"><TD CLASS="l">659</TD><TD>            if (toRemove != null) {  // then, remove removal set from new set</TD></TR><TR CLASS="c"><TD CLASS="l">660</TD><TD>                newSet.removeAll(toRemove);</TD></TR><TR><TD CLASS="l">661</TD><TD>            }</TD></TR><TR><TD CLASS="l">662</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">663</TD><TD>        return newSet;</TD></TR><TR><TD CLASS="l">664</TD><TD>    }</TD></TR><TR><TD CLASS="l">665</TD><TD> </TD></TR><TR><TD CLASS="l">666</TD><TD>    /**</TD></TR><TR><TD CLASS="l">667</TD><TD>     * This is a MagicDraw 12.5/16.0/16.5 specific method.</TD></TR><TR><TD CLASS="l">668</TD><TD>     *</TD></TR><TR><TD CLASS="l">669</TD><TD>     * For MagicDraw 12.5/16.0/16.5 files, the event that are owned</TD></TR><TR><TD CLASS="l">670</TD><TD>     * by a particular state machine are placed inside an</TD></TR><TR><TD CLASS="l">671</TD><TD>     * &lt;xmi:extension&gt; tag.  The reason for this is that *all* the</TD></TR><TR><TD CLASS="l"><A NAME="c">672</A></TD><TD>     * event (TimeEvent, SignalEvent, etc.) tags may be declared</TD></TR><TR><TD CLASS="l">673</TD><TD>     * at the top level</TD></TR><TR><TD CLASS="l">674</TD><TD>     */</TD></TR><TR><TD CLASS="l">675</TD><TD>    protected List&lt;Event&gt; getOwnedEvents (StateMachine stateMachine) {</TD></TR><TR CLASS="z"><TD CLASS="l">676</TD><TD>        List&lt;Event&gt; events = Util.newList();</TD></TR><TR><TD CLASS="l">677</TD><TD> </TD></TR><TR><TD CLASS="l">678</TD><TD>        // Use XPath to get all the idrefs of any</TD></TR><TR><TD CLASS="l">679</TD><TD>        // xmi:extention/modelExtension/event tags</TD></TR><TR><TD CLASS="l">680</TD><TD>        try {</TD></TR><TR CLASS="z"><TD CLASS="l">681</TD><TD>            String query = &#34;xmi:Extension/modelExtension/event/@xmi:idref&#34;;</TD></TR><TR CLASS="z"><TD CLASS="l">682</TD><TD>            NodeList idrefs = (NodeList) UMLElement.xpath.evaluate(query,</TD></TR><TR CLASS="z"><TD CLASS="l">683</TD><TD>                    ((UMLElement) stateMachine).getNode(),</TD></TR><TR CLASS="z"><TD CLASS="l">684</TD><TD>                    XPathConstants.NODESET);</TD></TR><TR><TD CLASS="l">685</TD><TD> </TD></TR><TR><TD CLASS="l">686</TD><TD>            // Look up the events based on the idrefs</TD></TR><TR CLASS="z"><TD CLASS="l">687</TD><TD>            for (int i = 0; i &lt; idrefs.getLength(); i++) {</TD></TR><TR CLASS="z"><TD CLASS="l">688</TD><TD>                String idref = idrefs.item(i).getNodeValue();</TD></TR><TR CLASS="z"><TD CLASS="l">689</TD><TD>                Element elem = ((UMLElement) stateMachine).xmi2uml(idref);</TD></TR><TR><TD CLASS="l">690</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">691</TD><TD>                if (elem instanceof Event) {</TD></TR><TR CLASS="z"><TD CLASS="l">692</TD><TD>                    events.add((Event) elem);</TD></TR><TR><TD CLASS="l">693</TD><TD>                }</TD></TR><TR><TD CLASS="l">694</TD><TD>            }</TD></TR><TR CLASS="z"><TD CLASS="l">695</TD><TD>        } catch (XPathExpressionException e) {</TD></TR><TR CLASS="z"><TD CLASS="l">696</TD><TD>            e.printStackTrace();</TD></TR><TR><TD CLASS="l">697</TD><TD>        }</TD></TR><TR><TD CLASS="l">698</TD><TD> </TD></TR><TR CLASS="z"><TD CLASS="l">699</TD><TD>        return events;</TD></TR><TR><TD CLASS="l">700</TD><TD>    }</TD></TR><TR><TD CLASS="l">701</TD><TD> </TD></TR><TR><TD CLASS="l">702</TD><TD> </TD></TR><TR><TD CLASS="l">703</TD><TD>    //////////////////////////////////</TD></TR><TR><TD CLASS="l">704</TD><TD>    // Miscellaneous utility methods</TD></TR><TR><TD CLASS="l"><A NAME="1d">705</A></TD><TD>    //////////////////////////////////</TD></TR><TR><TD CLASS="l">706</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">707</TD><TD>    private SimpleDateFormat dateFormatter = null;</TD></TR><TR><TD CLASS="l">708</TD><TD>    public String timestamp () {</TD></TR><TR CLASS="z"><TD CLASS="l">709</TD><TD>        if (dateFormatter == null) {</TD></TR><TR CLASS="z"><TD CLASS="l">710</TD><TD>            dateFormatter = new SimpleDateFormat(&#34;dd-MMM-yyyy HH:mm:ss&#34;);</TD></TR><TR><TD CLASS="l">711</TD><TD>        }</TD></TR><TR CLASS="z"><TD CLASS="l"><A NAME="2d">712</A></TD><TD>        return dateFormatter.format(Calendar.getInstance().getTime());</TD></TR><TR><TD CLASS="l">713</TD><TD>    }</TD></TR><TR><TD CLASS="l">714</TD><TD> </TD></TR><TR><TD CLASS="l">715</TD><TD>    public String username () {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2c">716</A></TD><TD>        return System.getProperty(&#34;user.name&#34;);</TD></TR><TR><TD CLASS="l">717</TD><TD>    }</TD></TR><TR><TD CLASS="l">718</TD><TD> </TD></TR><TR><TD CLASS="l">719</TD><TD>    public String toHexString (int value, int numDigits) {</TD></TR><TR CLASS="c"><TD CLASS="l">720</TD><TD>        return Util.toHexString(value, numDigits);</TD></TR><TR><TD CLASS="l">721</TD><TD>    }</TD></TR><TR><TD CLASS="l">722</TD><TD> </TD></TR><TR><TD CLASS="l">723</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../index.html">all classes</A>][<A HREF="4.html">gov.nasa.jpl.statechart.template</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://www.eclemma.org/support.html">EMMA 2.0.5312 EclEmma Fix 1</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>