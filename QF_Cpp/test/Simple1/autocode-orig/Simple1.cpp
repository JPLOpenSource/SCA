/**
 * @file Simple1.c
 *
 * This file was generated by the SIM MagicDraw statechart converter 
 * which converts MagicDraw statecharts expressed in XML to Miro Samek's
 * C Quantum Framework.
 *
 * &copy; 2009-2010 Jet Propulsion Lab / California Institute of Technology
 */


#include <stdlib.h>
#include <string.h>
#include "qep_port.h"
#include "qassert.h"
#include "StatechartSignals.h"
#include "Simple1.h"
#include "Simple1Impl.h"
#include "log_event.h"

/** 
 * Simple1 Constructor
 *
 * This function is responsible for initializing the object,
 * allocating and initializing any orthogonal regions, and 
 * initializing the timers.
 */
Simple1::Simple1 (const char *objNameNew, Simple1Impl *implObj, QActive *parent, bool isSubstate)
		: QActive((QStateHandler) &Simple1::initial) {
	strcpy(this->objName, objNameNew);
	strcat(this->objName, ":Simple1");
	this->impl = implObj;
	this->parent = parent;
	this->isSubstate = isSubstate;
}

Simple1::~Simple1() {
}

/**
 * Initial pseudostate of the state machine
 */
QState Simple1::initial(Simple1 *me, QEvent const *e) {
	/**
	 * Subscribe to all the signals to which this state machine needs
	 * to respond. This includes all the signals defined for any
	 * reachable submachine as well.  The signals are stored in the
	 * ownedMember association of the UML Namespace class.
	 */
	me->subscribe(Ev1);

	return Q_TRAN(&Simple1::S1);
}

/**
 * Implementation of state handler for S1
 */
QState Simple1::S1(Simple1 *me, QEvent const *e) {
	char stateName[256];
	strcpy(stateName, me->objName);
	strcat(stateName, " S1");

	switch (e->sig) {
	case Q_ENTRY_SIG: {
		me->myState = SIMPLE1_S1;
		strcat(stateName, " ENTRY");
		LogEvent::log(stateName);
		return Q_HANDLED();
	}
	case Q_EXIT_SIG: {
		strcat(stateName, " EXIT");
		LogEvent::log(stateName);
		return Q_HANDLED();
	}
	case Ev1: {
		strcat(stateName, " Ev1");
		LogEvent::log(stateName);
		return Q_TRAN(&Simple1::S2);
	}}
	return Q_SUPER(&QHsm::top);
}

/**
 * Implementation of state handler for S2
 */
QState Simple1::S2(Simple1 *me, QEvent const *e) {
	char stateName[256];

	strcpy(stateName, me->objName);
	strcat(stateName, " S2");

	switch (e->sig) {
	case Q_ENTRY_SIG: {
		me->myState = SIMPLE1_S2;
		strcat(stateName, " ENTRY");
		LogEvent::log(stateName);
		return Q_HANDLED();
	}
	case Q_EXIT_SIG: {
		strcat(stateName, " EXIT");
		LogEvent::log(stateName);
		return Q_HANDLED();
	}
	case Ev1: {
		strcat(stateName, " Ev1");
		LogEvent::log(stateName);
		return Q_TRAN(&Simple1::S1);
	}}
	return Q_SUPER(&QHsm::top);
}
