#!/usr/bin/env python -i
"""
Basic main state simulator application.

This program runs Statechart generated Python state-machines
by:

1. Looking for a gui.py file in the PYTHONPATH

2. glob ether a specified targert directory using the command line
   option 'p' or search in a default './autocode' sub-directory
   if one exists and establishing a list of generated State machines.

3. Generate an updated Application.py module

4. Check for a StateChartSignals module

5. Iterating over all *Active.py and *Impl.py to include them.

6. Executing QF python module initialization and startup of
each state machine thread active object.

7. End result is a set of state-machine specified on a command line
running and a python prompt displayed.

This module contains a simple API to make it easy
for end users to develop scenerio simulations against.

These routines for are used when importing this module into a
script.  Use the main routine to initialize and start the active
objects.  Then use sendEvent to send events to them, use tick to advance
any delays and use currentState to query for current state that a
state-machine is in.

main(args, nogui_flag = True, noimpl_flag = False, log = None, list_flag = False, path = None):

sendEvent(e): Send an Event, a tick, a signal or quit.

sendAndWait(signal, delay): Send an event and wait for 'delay' seconds.

tick(): Processes all armed time events at every clock tick.

currentState(state_machine_name): Return name of current state that a state machine is in.

There are three module global variables that can be used:

IMPL is a dictionary of *Impl.py objects.  For hand implementation of guards and actions.
ACTIVE is a dictionary of *Active.py objects.  These are the threaded modules running the state-machines.
qf is a reference to the Python qf singleton.

"""
import sys
import os
import signal
import subprocess
import string
import logging
import glob
import atexit
import Tkinter
#
# For Timeline GUI add SocketHandler
from logging import handlers
##
#
# default directory to look for generated python code generated by the Makefile and autocoder
#
AUTOCODE = "." + os.sep + "autocode"
#
# global implementation object dictionary
#
IMPL = dict()
ACTIVE = dict()
GUI_PY = None
qf = None
#
# required qf python modules from qf package
#
from qf import active
from qf import framework

#
# globel util functions for opt parse processing options
#
def setTargetDir(dir):
    """
    Update module global AUTOCODE path
    and PYTHONPATH env variable.
    """
    global AUTOCODE, GUI_PY
    
    if dir != None:  # override default value of AUTOCODE
        AUTOCODE = dir
    print "Setting target model set search directory to: %s" % AUTOCODE
    if os.path.exists(AUTOCODE) == False:
        print "ERROR: Target model set path, does not exist!"
        sys.exit(-1)
    #
    # Must include this so that gui.py can find the generated Application.py module.
    #
    if 'PYTHONPATH' in os.environ:
        PYTHON_PATHS = os.environ['PYTHONPATH']
        PYTHON_PATH_LIST = PYTHON_PATHS.split(os.pathsep)
        if AUTOCODE in PYTHON_PATH_LIST:
            pass
        else:
            os.environ['PYTHONPATH'] = PYTHON_PATHS + os.pathsep + AUTOCODE
    else:
        os.environ['PYTHONPATH'] = AUTOCODE
    sys.path.append(AUTOCODE)
    #
    #gui_file = "gui.py"
    gui_file = "gui_server.py"
    print "Searching PYTHONPATH directories for a %s to use." % gui_file
    #
    # Look for gui.py here.
    #
    PYTHON_PATHS = os.environ['PYTHONPATH']
    PYTHON_PATH_LIST = PYTHON_PATHS.split(os.pathsep)
    GUI_PY = None
    for p in PYTHON_PATH_LIST:
        for file in glob.glob(p + os.sep + "*"):
            if gui_file == os.path.basename(file):
                GUI_PY = file
                print "Found: %s" % GUI_PY
                return
        for file in glob.glob(p + os.sep + "qf" + os.sep + "*"):
            if gui_file == os.path.basename(file):
                GUI_PY = file
                print "Found: %s" % GUI_PY
                return
    # gui.py file not found so it is does not exist, bail!
    if GUI_PY == None:
        print "Uh oh! expecting to find %s in QF-Py/src/qf, but it's not there!" % gui_file
        sys.exit(-1)



class StartStateSim(object):
    """
    Setup an autocoded state simulation and start all threads.
    """
    __instance = None

    def __init__(self):
        """
        Constructor
        """
        self.__autocode_path = AUTOCODE
        #
        # Timeline GUI process, only used if timeline.py exists
        self.__timeline_process = None
        #
        # Storage of Active, Impl and Trace gui class modules.
        self.__state_machine_list = list()
        self.__active_modules = list()
        self.__impl_modules = list()
        #
        self.__active_modules_dict = dict()
        self.__impl_modules_dict = dict()
        self.__submachines_dict = dict()  # to prevent activating submachines
        #
        # Logging handler
        self.__logger_output_handler = None
        self.__logger_output_socket = None
        self.__logger_file_handler = None
        #
        # glob the autocode subdirectory
        # if one exists and establishing a
        # list of generated State machines.
        #
        self.globAutocode()
        if len(self.__active_modules) == 0:
            print "No generated state machines found..."
            if os.path.exists(self.__autocode_path + os.sep + "main.c"):
                # C implementation, so don't exit!
                print "C StateMachine implementation detected, continuing..."
            elif os.path.exists(self.__autocode_path + os.sep + "main.cpp"):
                # C++ implementation, so don't exit!
                print "C++ StateMachine implementation detected, continuing..."
            else:
                sys.exit(0)
        else:
            print "Found active object state machines and importing..." 
        # Import active objects and any impl here
        for active in self.__active_modules:
            cmd = "import " + active
            print cmd
            exec(cmd)
            self.__active_modules_dict[active] = locals()[active]
        # Include all Active and Impl modules found
        if len(self.__impl_modules) == 0:
            print "No user implementation modules found..."
        else:
            print "Found user implementation modules and importing..."
        for impl in self.__impl_modules:
            cmd ="import " + impl
            print cmd
            exec(cmd)
            self.__impl_modules_dict[impl] = locals()[impl]
        
        # Check for StateChartSignals module
        if os.path.exists(self.__autocode_path + os.sep + "StatechartSignals.py") == False:
            print "StatechartSignals.py is missing, rerun autocoder to generate it."
            sys.exit(-1)
        
        # Set up stuff for window tiling
        self.__win_offset_x = 0
        self.__win_offset_y = 0
        # Get fixed screen size here
        root = Tkinter.Tk()
        self.__screen_width = root.winfo_screenwidth()
        self.__screen_height = root.winfo_screenheight()
        root.destroy()
        print "Determined screen size to be: %d(w) x %d(h)" % (self.__screen_width, self.__screen_height)
        # This stores the row maximum increment for tiling
        self.row_h_max = 0
        # These are set to x,y padding to keep window away from edge of screen and each other
        self.xpad = 30
        self.ypad = 30

    def destroy(self):
        """
        Destroys singleton instance to allow reloading the QF framework.

        The main purpose of this destroy() is for clean unit-test runs.
        We attempt thorough cleansing to make sure no old data is used
        between unit-test runs.
        """
        # destroy the QF framework singleton
        framework.QF.destroy()
        #
        # reset global vars
        global ACTIVE, IMPL, AUTOCODE, GUI_PY, qf
        for a in ACTIVE.keys():
            #print "*** Deleting object %s" % ACTIVE[a]
            del ACTIVE[a]  # delete the instantiated Active object
        del ACTIVE
        for i in IMPL.keys():
            #print "*** Deleting object %s" % IMPL[i]
            del IMPL[i]  # delete the instantiated Impl object
        del IMPL
        ACTIVE = dict()
        IMPL = dict()
        GUI_PY = None
        qf = None
        # remove old AUTOCODE dir from PYTHONPATH and sys.path
        PYTHON_PATHS = os.environ['PYTHONPATH']
        PYTHON_PATH_LIST = PYTHON_PATHS.split(os.pathsep)
        if AUTOCODE in PYTHON_PATH_LIST:
            PYTHON_PATH_LIST.remove(AUTOCODE)
            PYTHON_PATHS = string.join(PYTHON_PATH_LIST, os.pathsep)
            os.environ['PYTHONPATH'] = PYTHON_PATHS
            sys.path.remove(AUTOCODE)
        #
        # destroy all member objects
        if self.__timeline_process is not None:
            # attempt to terminate timeline GUI by SIGTERM
            try: 
                os.kill(self.__timeline_process.pid, signal.SIGTERM)
            except Exception, info:
                print "Unable to terminate the Timeline GUI! Please manually quit it. %s" % info
            del self.__timeline_process
        #
        # Delete the LOGGERs in active modules
        for active in self.__active_modules:
            if active in self.__active_modules_dict:
                logger = self.__active_modules_dict[active].LOGGER                
                #print "** Cleaning up logger %s" % logger
                if self.__logger_output_handler is not None:
                    logger.removeHandler(self.__logger_output_handler)
                if self.__logger_output_socket is not None:
                    logger.removeHandler(self.__logger_output_socket)
                if self.__logger_file_handler is not None:
                    logger.removeHandler(self.__logger_file_handler)
                del self.__active_modules_dict[active].LOGGER
        #
        del self.__active_modules_dict
        del self.__impl_modules_dict
        for active in self.__active_modules:
            if active in sys.modules:
                del sys.modules[active]
        del self.__active_modules
        for impl in self.__impl_modules:
            if impl in sys.modules:
                del sys.modules[impl]
        del self.__impl_modules
        for sm in self.__state_machine_list:
            if sm in sys.modules:
                del sys.modules[sm]
        del self.__state_machine_list
        #
        # Delete out own logging handlers but do NOT shutdown logging
        #print "** Deleting logging handlers"
        if self.__logger_output_handler is not None:
            self.__logger_output_handler.close()
        if self.__logger_output_socket is not None:
            self.__logger_output_socket.close()
        if self.__logger_file_handler is not None:
            self.__logger_file_handler.close()
        #print "*** Destroyed StartStateSim singleton %s! ***" % self


    def getInstance():
        """
        Return instance of singleton.
        """
        if(StartStateSim.__instance is None):
            StartStateSim.__instance = StartStateSim()
        return StartStateSim.__instance

    def cleanUp():
        """
        Clean-up code registered with the atexit module.
        """
        # destroy singleton StartStateSim instance
        if StartStateSim is not None and StartStateSim.__instance is not None:
            StartStateSim.__instance.destroy()
            # unset singleton instance
            StartStateSim.__instance = None

    # define static methods
    getInstance = staticmethod(getInstance)
    cleanUp = staticmethod(cleanUp)


    def __call__(self, state_machine_list, noimpl_flag, log_filename=None):
        """
        Initialization of Python qf module and
        startup of all state machine threads.
        """
        global IMPL, ACTIVE
        # Log to stdout only.
        self.__logger_output_handler = logging.StreamHandler(sys.stdout)
        # Connect to timeline GUI if it is running
        self.__logger_output_socket = None
        if self.__timeline_process is not None:
            self.__logger_output_socket = handlers.SocketHandler('localhost', 7777)
        #
        if log_filename != None:
            self.__logger_file_handler = logging.FileHandler(log_filename)
        self.__logger_output_handler.setLevel(logging.INFO)
        # Include only message in output.
        #logger_formatter = logging.Formatter('%(thread)d:%(name)s %(message)s')
        logger_formatter = logging.Formatter('%(message)s')
        self.__logger_output_handler.setFormatter(logger_formatter)
        #
        #print "sys.modules:", sorted(sys.modules.keys())
        smsToActivate = list()
        for active in self.__active_modules:
            names = map(lambda x: x + "Active", state_machine_list)
            if (len(state_machine_list)==0) or (active in names)==True:
                smsToActivate.append(active)
                # Get actual module here.
                mod = self.__active_modules_dict[active]
                # Enable logger as info messages only.
                mod.LOGGER.setLevel(logging.INFO)
                mod.LOGGER.addHandler(self.__logger_output_handler)
                if log_filename !=None:
                    print "Attaching log file handler: %s\n" % log_filename
                    mod.LOGGER.addHandler(self.__logger_file_handler)
                #
                # Add socket handler for timeline GUI.
                #
                if self.__timeline_process is not None:
                    mod.LOGGER.addHandler(self.__logger_output_socket)
        #
        # Instantiate and activate all StateMachines and impls first in
        # separate loops to avoid dependency on order of logger setup, and to
        # allow ACTIVE and IMPL dicts to be printed out before SM activation.
        submImplsToFind = dict()
        for active in smsToActivate:
            sm_name = active.split("Active")[0]
            sm_name_impl = sm_name + "Impl"
            # Instance any Impl module and active object, excluding submachines
            if active in self.__submachines_dict.keys():
                if sm_name_impl in self.__impl_modules_dict.keys():
                    # No instancing; gather submachine impl for access via IMPL
                    submImplsToFind[sm_name] = active
            else:  # Active is NOT a submachine
                mod = self.__active_modules_dict[active]
                if sm_name_impl in self.__impl_modules_dict.keys():
                    mod_impl = self.__impl_modules_dict[sm_name_impl]
                    # Instance active object with impl instance here
                    impl = mod_impl.__dict__[sm_name_impl]()
                    s = mod.__dict__[active](impl)
                    IMPL[sm_name] = impl
                else:
                    # Instance active object here without impl object
                    s = mod.__dict__[active]()
                # Build global of active objects keyed on state machine name.
                ACTIVE[sm_name] = s
        #
        # Find submachine Impls within the ACTIVE objects
        # TODO only able to find submachines one-level down!
        for subm_name in submImplsToFind.keys():
            substate_name = self.__submachines_dict[submImplsToFind[subm_name]]
            for sm_name in ACTIVE.keys():
                mod = ACTIVE[sm_name]
                try:
                    mod_impl = eval("mod._%sActive__%sImpl" % (sm_name, substate_name))
                    # found submachine impl! add to IMPL
                    IMPL[substate_name] = mod_impl
                except AttributeError:
                    continue
        #
        # Print the accessible ACTIVE and IMPL objects
        print "*Accessible Active and Impl objects:"
        print "  ACTIVE%s" % ACTIVE.keys()
        print "    IMPL%s" % IMPL.keys()
        #
        # Finally, activate the ACTIVEs
        for s in ACTIVE.values():
            # Active object start up and register with QF
            s.startActive()
            # start/initialize HSM
            s.onStart(s.top)
            s.start()


    def globAutocode(self):
        """
        Find all active, impl, and trace modules looking ONLY at trace .py files
        """
        for a in glob.glob( self.__autocode_path + os.sep + "*.py" ):
            #
            # A candidate may be *Active or *Impl, neither of which we want
            candidate = a.split(os.sep)[-1].split(".")[0]
            if candidate == "StatechartSignals" or\
                    candidate == "Application" or\
                    candidate == "timeline" or\
                    candidate[-6:] == "Active" or candidate[-4:] == "Impl":
                # skip signals file, Application, Active, and Impl python files
                continue
            else:  # check 2 attributes to make sure the file is a trace GUI
                exec("import " + candidate)
                if 'MAGICDRAW_WINDOW_WIDTH' in locals()[candidate].__dict__.keys() and\
                   'MAGICDRAW_WINDOW_HEIGHT' in locals()[candidate].__dict__.keys():
                    pass  # FOUND a candidate trace GUI!
                else:
                    #print "Ignoring %s..." % candidate
                    continue  # skip this candidate, NOT a trace GUI
            #
            print a
            trace_module = candidate
            self.__state_machine_list.append(trace_module)
            #
            # check for active modules here and add them.
            active_module = trace_module + "Active"
            if os.path.exists(self.__autocode_path + os.sep + active_module + ".py"):
                self.__active_modules.append(active_module)
            #
            # check for impl modules here and add them.
            impl_module = trace_module + "Impl"
            if os.path.exists(self.__autocode_path + os.sep + impl_module + ".py"):
                self.__impl_modules.append(impl_module)


    def __gatherStateMachineList(self, machine_list):
        """
        Gather the list of state machine instances needed, accounting for
        Sub-StateMachines, by doing the following steps:

        - Iterate through the "*Active" state machines to look for submachines.

        - If any submachine is found, then the list of SMs becomes the
        submachines and the machine within which those submachines were found.

        - Once the list is finalized, return it for Application.py generation.
        """
        vars_list = list()
        state_machine_list = list()
        # Filter the needed machines
        for m in self.__state_machine_list:
            if (len(machine_list)==0) or (m in machine_list) == True:
                state_machine_list.append(m)
        for trace in state_machine_list:
            vars_list.append(trace.lower())
        #
        new_var_list = list()
        new_sm_list = list()
        win_label_map = dict()  # keep track of window labels, for submachines
        # Do first pass through list of state machines to find any submachines
        for ss in enumerate(state_machine_list):
            v = vars_list[ss[0]]
            s = ss[1]
            # import trace gui module to obtain submachines info, if any
            exec("import " + s)
            # obtain submachine list, if any
            try:
                submachines = eval(s + ".SUBMACHINE_STATES")
            except AttributeError:
                submachines = None
            if submachines is not None:
                # 1st add this machine to new list
                new_var_list.append(v)
                new_sm_list.append(s)
                # process the "var:SM" strings, and add submachines to new list
                for submStr in submachines:
                    strs = submStr.split(':')
                    if len(strs) < 2:
                        print "Submachine name '%s' in '%s' invalid!" % (submStr, s)
                        continue
                    varName = strs[0] + '_' + strs[1]
                    v = varName.lower()
                    s = strs[1]
                    new_var_list.append(v)
                    new_sm_list.append(s)
                    win_label_map[v] = submStr
                    active = "%sActive" % s
                    print "Identified submachine '%s', not activating %s..."\
                            % (submStr, active)
                    # add submachine to a separate dict for special treatment
                    self.__submachines_dict[active] = strs[0]
        # Do second pass through list to transfer over any non-submachines
        for ss in enumerate(state_machine_list):
            v = vars_list[ss[0]]
            s = ss[1]
            if s not in new_sm_list:  # add the missed, main, state machine
                new_var_list.append(v)
                new_sm_list.append(s)
        #
        # Return the state machine, var, and window label data structures.
        return (new_sm_list, new_var_list, win_label_map)


    def __limitWinSize(self, w,h):
        """
        Limit the window size so it will fit on the screen.
        """
        scr_w = self.__screen_width
        scr_h = self.__screen_height
        #
        aspect_ratio = float(w)/float(h)
        xpad = 2 * self.xpad
        ypad = 2 * self.ypad
        # padded an extra 100 for Mac OS dock clearence
        ypad_dock = 100
        #
        # check height
        if (h + ypad + ypad_dock) >= scr_h:
           
            h = scr_h  - ypad - ypad_dock
            if h < 500:
                h = 500 
            w = int( float(h)*aspect_ratio )
            # check width 
            if w + xpad >= scr_w:
                w= scr_w - xpad
        # check width        
        elif (w + xpad) >= scr_w:
            w = scr_w - xpad
            if w < 500:
                w = 500
            h = int( float(w)/aspect_ratio )
            # check height
            if h + xpad + ypad_dock >= scr_h:
                h = scr_h - ypad - ypad_dock

        return (w,h)


    def __tileWinOffset(self, w, h):
        """
        Compute the window offset to
        tile a set of trace widgets.
        """
        # offsets of window, laying each out left-to-right, then top-to-bottom
        xoff = self.__win_offset_x
        yoff = self.__win_offset_y
        #
        scr_w = self.__screen_width
        scr_h = self.__screen_height
        # if left->right over right edge
        if xoff+ w + self.xpad >= scr_w:
            xoff=self.xpad
            yoff=yoff+self.row_h_max + self.ypad
            # if top->bottom over bottom
            if yoff + h + 2*self.ypad >= scr_h:
                xoff=self.xpad
                yoff=self.ypad
        # default and do nothing if window with new offset fits ok
        self.__win_offset_x = xoff
        self.__win_offset_y = yoff


    def __tileWinOffsetIncr(self, w, h):
        """
        Increment window offset here.
        """
        self.__win_offset_x= self.__win_offset_x + w
        self.w=w
        self.h=h
        if h > self.row_h_max:
            self.row_h_max = h        


    def generateApplicationPy(self,machine_list,notile_flag=None):
        """
        Generate an Application.py module.
        """
        print "Creating Application.py module."
        (state_machine_list, vars_list, win_label_map) = self.__gatherStateMachineList(machine_list)
        f = open(self.__autocode_path + os.sep + "Application.py", "w")
        #
        # Write content of Application.py, starting with import statements
        #
        imported_list = list()  # to prevent duplicate import statements
        for trace in state_machine_list:
            if trace not in imported_list:
                f.write("import %s\n" % trace)
                imported_list.append(trace)
        f.write("\n")
        #
        #- next, the GUI update method and windowsReady method
        f.write("def update():\n")
        for v in vars_list:
            f.write("    %s.win.update()\n" % v)
        f.write("\n")
        #
        f.write("def windowsReady():\n")
        for v in vars_list:
            f.write("    #print \"%%s window state: %%s\" %% (%s.win.title(), %s.win.state())\n" % (v, v))
        for i in range(0,len(vars_list)):
            # print either 'return' or indentation
            if i == 0:
                f.write("    return ")
            else:
                f.write("           ")
            # print logical comparison
            f.write("%s.win.state() == 'normal'" % vars_list[i])
            # print 'and \' if not last line
            if i < len(vars_list)-1:
                f.write(" and \\\n")
        f.write("\n\n")
        #
        #- now, the window panels and their geometry info
        for ss in enumerate(state_machine_list):
            v = vars_list[ss[0]]
            s = ss[1]
            label = s
            if v in win_label_map:  # get submachine window label instead
                label = win_label_map[v]
            # import trace gui module to obtain window dimensions.
            exec("import " + s)
            # obtain dimensions of the CASE window
            w = int(eval(s + ".MAGICDRAW_WINDOW_WIDTH"))
            h = int(eval(s + ".MAGICDRAW_WINDOW_HEIGHT"))
            (w,h) = self.__limitWinSize(w, h)
            # compute new window offset here
            if notile_flag != True:
                self.__tileWinOffset(w,h)
            xoff = self.__win_offset_x + 30
            yoff = self.__win_offset_y  + 30          
            #
            f.write( "%s = %s.%s(\"%s\", big_name=True)\n" % (v,s,s,label))
            f.write( "%s.canvas.scale(\"all\", 0.0, 0.0, 1.00, 1.00)\n" % v)
            f.write( "%s.win.geometry(\'%sx%s+%s+%s\')\n" % (v,w,h,xoff,yoff) )
            f.write("\n")
            #
            # increment the window offset here
            if notile_flag != True:
                self.__tileWinOffsetIncr(w,h)
        #
        #- finally, the name-to-window maps
        f.write( "mapCharts = {\n")
        for v in vars_list:
            f.write( "\'%s\': %s,\n" % (v,v))
        f.write( "}\n" )
        #
        # Close Application.py file handle and delete the imported modules
        f.flush()
        f.close()
        print "Completed."


    def startTimelineGui(self):
        """
        Start the timeline GUI in a separate process.
        This process instance indicates that communication
        is needed with the timeline GUI via logging handle.
        """
        envPath = "/bin/env"
        if not os.path.exists(envPath):
            envPath = "/usr/bin/env"
        #
        self.__timeline_process = \
            subprocess.Popen([envPath, "python",
                              self.__autocode_path + os.sep + "timeline.py"])


    def list(self):
        """
        """
        i = 0
        print "\n State machines generated:"
        for sm in self.__active_modules:
            s = sm.split("Active")[0]
            print "%d.\t%s" % (i,s)
            i+=1
#
# A module API is defined starting here to make it easy
# for end users to develop against.
#
def main(args=[], nogui_flag = True, noimpl_flag = False, log = None,
         list_flag = False, path = None, notile_flag = None,
         dropped_flag = False, notimeline_flag = False):
    """
    Main routine.
    Codes that import this module must call this
    first to find auto-coded Python start things.
    
    @param args: a list of state machine names to be used or empty for all state machines.
    @param nogui_flag:  enable/disable trace gui (default: disabled for testing)
    @param noimpl_flag: enable/disable implementation class instancing (default: disabled) 
    @param log: record state transition information to log file, give a string logfile name.
    @param list_flag:  print list of autocoded state-machines found and exit.
    @param path: specify a target search path (default: ./autocode).
    @param dropped_flag:  enable/disable notification of dropped events (default: disabled)
    @param notimeline_flag:  enable/disable timeline GUI if available (default: enabled)
    """
    global qf
    #
    setTargetDir(path)
    print "Autocode path:  %s" % AUTOCODE
    #
    if list_flag == True:
        StartStateSim.getInstance().list()
        print "Exiting now..."
        sys.exit(0)
    #
    # Set up to run generated Python
    start_state_sim = StartStateSim.getInstance()
    # Shutdown the gui on exit
    atexit.register(StartStateSim.cleanUp)
    start_state_sim.generateApplicationPy(args, notile_flag)
    #
    # Start up Timeline GUI if it exists
    if not notimeline_flag and os.path.exists(AUTOCODE + os.sep + "timeline.py"):
        start_state_sim.startTimelineGui()
    #
    # Instance the QF code for running main thread and create active object.  
    qf = framework.QF.getInstance()
    #
    # Framework init
    if nogui_flag == False:
        qf.init(True,state_charts_h_file=AUTOCODE + os.sep + "StatechartSignals.h",
                gui_py_file=GUI_PY, notify_dropped_events=dropped_flag)
    else:
        qf.init(False, notify_dropped_events=dropped_flag)
    #
    # Start the state machine threads and initialize.
    start_state_sim(args, noimpl_flag, log)
    #
    # Run event dispatch loop
    qf.run(True)


def sendEvent(e):
    """
    Send an Event, a tick, a signal or quit.
    """
    # just forward the event on to the QF framework singleton
    framework.QF.getInstance().sendEvent(e)


def sendAndWait(signal, delay):
    """
    Send an event and wait for 'delay' seconds.
    """
    print "--> %s" % signal
    framework.QF.getInstance().sendAndWait(signal, delay)
    

def tick():
    """
    Processes all armed time events at every clock tick.
    """
    framework.QF.getInstance().tick()


def currentState(state_machine_name):
    """
    Return the current state that a state machine is in.
    @param state_machine_name: string name of state-machine
    @return: returns string name of state
    """
    if type('str') == type(state_machine_name):
        state = framework.QF.getInstance().getCurrentState(ACTIVE[state_machine_name])
    else:
        state = None
    return state

        
if __name__ == "__main__":
    from optparse import OptionParser

    usage = "usage: %prog [options] <State machine names>"
    vers  = "%prog "
    parser = OptionParser(usage, version=vers)
    parser.add_option("-l", "--list", dest="list_flag",
                      help="Print list of all generated state machines.",
                      action="store_true", default=False)
    parser.add_option("-n", "--nogui", dest="nogui_flag", 
                      help="Turn off trace gui displays.",
                      action="store_true", default=False)
    parser.add_option("-t","--notile", dest="notile_flag",
                      help="Turn off tiling of trace gui windows.",
                      action="store_true", default=False)
    parser.add_option("-i", "--noimpl", dest="noimpl_flag", 
                      help="Turn off hand coded implementation.",
                      action="store_true", default=False)
    parser.add_option("-p", "--path", dest="path", type="string",
                      help="Switch to new target directory. (default: %s)." % AUTOCODE,
                      action="store", default=AUTOCODE)
    parser.add_option("-L", "--log", "--logfile", dest="log", type="string",
                      help="Log all console output to a file. (default: %s)." % None)
    parser.add_option("-e", "--dropped-events", dest="dropped_flag",
                      help="Turn on notification of dropped events.",
                      action="store_true", default=False)
    parser.add_option("", "--notimeline", dest="notimeline_flag",
                      help="Turn off running timeline GUI.",
                      action="store_true", default=False)

    (opt, args) = parser.parse_args()

    main(args, opt.nogui_flag, opt.noimpl_flag, opt.log, opt.list_flag,
         opt.path, opt.notile_flag, opt.dropped_flag, opt.notimeline_flag)

