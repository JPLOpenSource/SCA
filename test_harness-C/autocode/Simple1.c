//===========================================================================
// This software contains Caltech/JPL confidential information.
//
// Copyright 2009-2016, by the California Institute of Technology.
// ALL RIGHTS RESERVED. United States Government Sponsorship Acknowledged.
// Any commercial use must be negotiated with the Office of Technology
// Transfer at the California Institute of Technology.
//
// This software may be subject to US export control laws and
// regulations. By accepting this document, the user agrees to comply
// with all applicable U.S. export laws and regulations, including the
// International Traffic and Arms Regulations, 22 C.F.R. 120-130 and the
// Export Administration Regulations, 15 C.F.R. 730-744. User has the
// responsibility to obtain export licenses, or other export authority as
// may be required before exporting such information to foreign countries
// or providing access to foreign persons.
//===========================================================================
//
//       File: Simple1.c
// Created on: 25-Apr-2016 10:11:52
//     Author: watney@jpl.nasa.gov
// SCACmdLine: -c -sm Simple1 ../Simple.mdxml
//
// This file was generated by the JPL StateChart Autocoders, which converts UML
// Statecharts, in XML, to a C variant of Miro Samek's Quantum Framework.
//===========================================================================
#include <stdio.h>
#include <string.h>
#include <log_event.h>
#include <assert.h>
#include <Simple1.h>
#include <Simple1Impl.h>

/**
 * Simple1 Constructor
 */
Simple1 *Simple1_Constructor (Simple1 *me, const char *objNameNew, Simple1Impl *implObj, QActive *active) {
    QActive_ctor((QActive *)me, (QStateHandler )&Simple1_initial);
    strncpy(me->objName, objNameNew, 128);
    strncat(me->objName, ":Simple1", 128-strlen(me->objName));
    me->impl = implObj;
    if (0 == active) {  // self IS the active object
        me->active = (QActive *)me;
    } else {  // set containing machine as active object
        me->active = active;
    }
    Simple1Impl_set_qactive(me->impl, me->active);  // give impl access to parent QActive

    // State is initially at TOP
    me->myState = SIMPLE1__TOP__;

    return me;
}

Simple1Impl *Simple1_getImpl (Simple1 *me) {
    return me->impl;
}

Simple1_state Simple1_getCurrentState (Simple1 *me) {
    return me->myState;
}

bool Simple1_is_substate (Simple1 *me) {
    return (me->active != (QActive *)me);
}

void Simple1_reinit (Simple1 *me) {
    ((QHsm *)me)->state = (QStateHandler )&Simple1_initial;
}

/**
 * Initial pseudostate of the state machine.
 *
 * This routine handles initial events of the state-machine.
 */
QState Simple1_initial (Simple1 *me, QEvent const *e) {

    /**
     * Subscribe to all the signals to which this state machine needs
     * to respond. This includes all the signals defined for any
     * reachable submachines as well.  The signals are stored in the
     * ownedMember association of the UML Namespace class.
     */
    if (me->active == (QActive *)me) {
        QActive_subscribe(me->active, EV1_SIG);
    }  // Do NOT subscribe to events if a submachine

    return Q_TRAN(&Simple1_S1);
}

/**
 * State S1
 */
QState Simple1_S1 (Simple1 *me, QEvent const *e) {
    char stateName[128];
    strncpy(stateName, me->objName, 128);
    strncat(stateName, " S1", 128-strlen(stateName)-1/*null-char*/);

    char logMsg[256];
    strncpy(logMsg, stateName, 256);  // strncat below null-terminates

    switch (e->sig) {

    case Q_ENTRY_SIG:
        me->myState = SIMPLE1_S1;
        strncat(logMsg, " ENTRY", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_HANDLED();

    case Q_EXIT_SIG:
        strncat(logMsg, " EXIT", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_HANDLED();

    case EV1_SIG:
        strncat(logMsg, " Ev1", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_TRAN(&Simple1_S2);
    }
    return Q_SUPER(&QHsm_top);
}

/**
 * State S2
 */
QState Simple1_S2 (Simple1 *me, QEvent const *e) {
    char stateName[128];
    strncpy(stateName, me->objName, 128);
    strncat(stateName, " S2", 128-strlen(stateName)-1/*null-char*/);

    char logMsg[256];
    strncpy(logMsg, stateName, 256);  // strncat below null-terminates

    switch (e->sig) {

    case Q_ENTRY_SIG:
        me->myState = SIMPLE1_S2;
        strncat(logMsg, " ENTRY", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_HANDLED();

    case Q_EXIT_SIG:
        strncat(logMsg, " EXIT", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_HANDLED();

    case EV1_SIG:
        strncat(logMsg, " Ev1", 256-strlen(logMsg)-1/*null-char*/);
        LogEvent_log(logMsg);
        return Q_TRAN(&Simple1_S1);
    }
    return Q_SUPER(&QHsm_top);
}
